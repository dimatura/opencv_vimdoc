*cv-core.txt*	For Vim 0.0	Thu May 19 18:07:34 2011

Navigation

  • index
  • next |
  • previous |
  • opencv v2.1 documentation »
  • core. The Core Functionality »

Basic Structures~

===========================================================================
*cv-DataType*

Template “traits” class for other OpenCV primitive data types

template<typename _Tp> class DataType
{
    // value_type is always a synonym for _Tp.
    typedef _Tp value_type;

    // intermediate type used for operations on _Tp.
    // it is int for uchar, signed char, unsigned short, signed short and int,
    // float for float, double for double, ...
    typedef <...> work_type;
    // in the case of multi-channel data it is the data type of each channel
    typedef <...> channel_type;
    enum
    {
        // CV_8U ... CV_64F
        depth = DataDepth<channel_type>::value,
        // 1 ...
        channels = <...>,
        // '1u', '4i', '3f', '2d' etc.
        fmt=<...>,
        // CV_8UC3, CV_32FC2 ...
        type = CV_MAKETYPE(depth, channels)
    };
};

The template class DataType is descriptive class for OpenCV primitive data
types and other types that comply with the following definition. A primitive
OpenCV data type is one of unsigned char, bool, signed char, unsigned short,
signed short, int, float, double or a tuple of values of one of these types,
where all the values in the tuple have the same type. If you are familiar with
OpenCV CvMat ‘s type notation, CV _ 8U ... CV _ 32FC3, CV _ 64FC2 etc., then a
primitive type can be defined as a type for which you can give a unique
identifier in a form CV_<bit-depth>{U|S|F}C<number_of_channels> . A universal
OpenCV structure able to store a single instance of such primitive data type is
Vec . Multiple instances of such a type can be stored to a std::vector , Mat ,
Mat_ , SparseMat , SparseMat_ or any other container that is able to store Vec
instances.

The class DataType is basically used to provide some description of such
primitive data types without adding any fields or methods to the corresponding
classes (and it is actually impossible to add anything to primitive C/C++ data
types). This technique is known in C++ as class traits. It’s not DataType
itself that is used, but its specialized versions, such as:

template<> class DataType<uchar>
{
    typedef uchar value_type;
    typedef int work_type;
    typedef uchar channel_type;
    enum { channel_type = CV_8U, channels = 1, fmt='u', type = CV_8U };
};
...
template<typename _Tp> DataType<std::complex<_Tp> >
{
    typedef std::complex<_Tp> value_type;
    typedef std::complex<_Tp> work_type;
    typedef _Tp channel_type;
    // DataDepth is another helper trait class
    enum { depth = DataDepth<_Tp>::value, channels=2,
        fmt=(channels-1)*256+DataDepth<_Tp>::fmt,
        type=CV_MAKETYPE(depth, channels) };
};
...

The main purpose of the classes is to convert compile-time type information to
OpenCV-compatible data type identifier, for example:

// allocates 30x40 floating-point matrix
Mat A(30, 40, DataType<float>::type);

Mat B = Mat_<std::complex<double> >(3, 3);
// the statement below will print 6, 2 /* i.e. depth == CV_64F, channels == 2 */
cout << B.depth() << ", " << B.channels() << endl;

that is, such traits are used to tell OpenCV which data type you are working
with, even if such a type is not native to OpenCV (the matrix B intialization
above compiles because OpenCV defines the proper specialized template class
DataType<complex<_Tp> > ). Also, this mechanism is useful (and used in OpenCV
this way) for generic algorithms implementations.

===========================================================================
*cv-Point_*

Template class for 2D points

template<typename _Tp> class Point_
{
public:
    typedef _Tp value_type;

    Point_();
    Point_(_Tp _x, _Tp _y);
    Point_(const Point_& pt);
    Point_(const CvPoint& pt);
    Point_(const CvPoint2D32f& pt);
    Point_(const Size_<_Tp>& sz);
    Point_(const Vec<_Tp, 2>& v);
    Point_& operator = (const Point_& pt);
    template<typename _Tp2> operator Point_<_Tp2>() const;
    operator CvPoint() const;
    operator CvPoint2D32f() const;
    operator Vec<_Tp, 2>() const;

    // computes dot-product (this->x*pt.x + this->y*pt.y)
    _Tp dot(const Point_& pt) const;
    // computes dot-product using double-precision arithmetics
    double ddot(const Point_& pt) const;
    // returns true if the point is inside the rectangle "r".
    bool inside(const Rect_<_Tp>& r) const;

    _Tp x, y;
};

The class represents a 2D point, specified by its coordinates x and y .
Instance of the class is interchangeable with C structures CvPoint and
CvPoint2D32f . There is also cast operator to convert point coordinates to the
specified type. The conversion from floating-point coordinates to integer
coordinates is done by rounding; in general case the conversion uses operation
on each of the coordinates. Besides the class members listed in the declaration
above, the following operations on points are implemented:

pt1 = pt2 + pt3;
pt1 = pt2 - pt3;
pt1 = pt2 * a;
pt1 = a * pt2;
pt1 += pt2;
pt1 -= pt2;
pt1 *= a;
double value = norm(pt); // L2 norm
pt1 == pt2;
pt1 != pt2;

For user convenience, the following type aliases are defined:

typedef Point_<int> Point2i;
typedef Point2i Point;
typedef Point_<float> Point2f;
typedef Point_<double> Point2d;

Here is a short example:

Point2f a(0.3f, 0.f), b(0.f, 0.4f);
Point pt = (a + b)*10.f;
cout << pt.x << ", " << pt.y << endl;

===========================================================================
*cv-Point3_*

Template class for 3D points

template<typename _Tp> class Point3_
{
public:
    typedef _Tp value_type;

    Point3_();
    Point3_(_Tp _x, _Tp _y, _Tp _z);
    Point3_(const Point3_& pt);
    explicit Point3_(const Point_<_Tp>& pt);
    Point3_(const CvPoint3D32f& pt);
    Point3_(const Vec<_Tp, 3>& v);
    Point3_& operator = (const Point3_& pt);
    template<typename _Tp2> operator Point3_<_Tp2>() const;
    operator CvPoint3D32f() const;
    operator Vec<_Tp, 3>() const;

    _Tp dot(const Point3_& pt) const;
    double ddot(const Point3_& pt) const;

    _Tp x, y, z;
};

The class represents a 3D point, specified by its coordinates x , y and z .
Instance of the class is interchangeable with C structure CvPoint2D32f .
Similarly to Point_ , the 3D points’ coordinates can be converted to another
type, and the vector arithmetic and comparison operations are also supported.

The following type aliases are available:

typedef Point3_<int> Point3i;
typedef Point3_<float> Point3f;
typedef Point3_<double> Point3d;

===========================================================================
*cv-Size_*

Template class for specfying image or rectangle size.

template<typename _Tp> class Size_
{
public:
    typedef _Tp value_type;

    Size_();
    Size_(_Tp _width, _Tp _height);
    Size_(const Size_& sz);
    Size_(const CvSize& sz);
    Size_(const CvSize2D32f& sz);
    Size_(const Point_<_Tp>& pt);
    Size_& operator = (const Size_& sz);
    _Tp area() const;

    operator Size_<int>() const;
    operator Size_<float>() const;
    operator Size_<double>() const;
    operator CvSize() const;
    operator CvSize2D32f() const;

    _Tp width, height;
};

The class Size_ is similar to Point_ , except that the two members are called
width and height instead of x and y . The structure can be converted to and
from the old OpenCV structures CvSize and CvSize2D32f . The same set of
arithmetic and comparison operations as for Point_ is available.

OpenCV defines the following type aliases:

typedef Size_<int> Size2i;
typedef Size2i Size;
typedef Size_<float> Size2f;

===========================================================================
*cv-Rect_*

Template class for 2D rectangles

template<typename _Tp> class Rect_
{
public:
    typedef _Tp value_type;

    Rect_();
    Rect_(_Tp _x, _Tp _y, _Tp _width, _Tp _height);
    Rect_(const Rect_& r);
    Rect_(const CvRect& r);
    // (x, y) <- org, (width, height) <- sz
    Rect_(const Point_<_Tp>& org, const Size_<_Tp>& sz);
    // (x, y) <- min(pt1, pt2), (width, height) <- max(pt1, pt2) - (x, y)
    Rect_(const Point_<_Tp>& pt1, const Point_<_Tp>& pt2);
    Rect_& operator = ( const Rect_& r );
    // returns Point_<_Tp>(x, y)
    Point_<_Tp> tl() const;
    // returns Point_<_Tp>(x+width, y+height)
    Point_<_Tp> br() const;

    // returns Size_<_Tp>(width, height)
    Size_<_Tp> size() const;
    // returns width*height
    _Tp area() const;

    operator Rect_<int>() const;
    operator Rect_<float>() const;
    operator Rect_<double>() const;
    operator CvRect() const;

    // x <= pt.x && pt.x < x + width &&
    // y <= pt.y && pt.y < y + height ? true : false
    bool contains(const Point_<_Tp>& pt) const;

    _Tp x, y, width, height;
};

The rectangle is described by the coordinates of the top-left corner (which is
the default interpretation of Rect_::x and Rect_::y in OpenCV; though, in your
algorithms you may count x and y from the bottom-left corner), the rectangle
width and height.

Another assumption OpenCV usually makes is that the top and left boundary of
the rectangle are inclusive, while the right and bottom boundaries are not, for
example, the method Rect_::contains returns true if

x \leq pt.x < x+width, y \leq pt.y < y+height

And virtually every loop over an image ROI in OpenCV (where ROI is specified by
Rect_<int> ) is implemented as:

for(int y = roi.y; y < roi.y + rect.height; y++)
    for(int x = roi.x; x < roi.x + rect.width; x++)
    {
        // ...
    }

In addition to the class members, the following operations on rectangles are
implemented:

  • rect = rect \pm point (shifting rectangle by a
    certain offset)
  • rect = rect \pm size (expanding or shrinking
    rectangle by a certain amount)
  • rect += point, rect -= point, rect += size, rect -= size (augmenting
    operations)
  • rect = rect1 & rect2 (rectangle intersection)
  • rect = rect1 | rect2 (minimum area rectangle containing rect2 and rect3 )
  • rect &= rect1, rect |= rect1 (and the corresponding augmenting operations)
  • rect == rect1, rect != rect1 (rectangle comparison)

Example. Here is how the partial ordering on rectangles can be established
(rect1 \subseteq rect2):

template<typename _Tp> inline bool
operator <= (const Rect_<_Tp>& r1, const Rect_<_Tp>& r2)
{
    return (r1 & r2) == r1;
}

For user convenience, the following type alias is available:

typedef Rect_<int> Rect;

===========================================================================
*cv-RotatedRect*

Possibly rotated rectangle

class RotatedRect
{
public:
    // constructors
    RotatedRect();
    RotatedRect(const Point2f& _center, const Size2f& _size, float _angle);
    RotatedRect(const CvBox2D& box);

    // returns minimal up-right rectangle that contains the rotated rectangle
    Rect boundingRect() const;
    // backward conversion to CvBox2D
    operator CvBox2D() const;

    // mass center of the rectangle
    Point2f center;
    // size
    Size2f size;
    // rotation angle in degrees
    float angle;
};

The class RotatedRect replaces the old CvBox2D and fully compatible with it.

===========================================================================
*cv-TermCriteria*

Termination criteria for iterative algorithms

class TermCriteria
{
public:
    enum { COUNT=1, MAX_ITER=COUNT, EPS=2 };

    // constructors
    TermCriteria();
    // type can be MAX_ITER, EPS or MAX_ITER+EPS.
    // type = MAX_ITER means that only the number of iterations does matter;
    // type = EPS means that only the required precision (epsilon) does matter
    //    (though, most algorithms put some limit on the number of iterations anyway)
    // type = MAX_ITER + EPS means that algorithm stops when
    // either the specified number of iterations is made,
    // or when the specified accuracy is achieved - whatever happens first.
    TermCriteria(int _type, int _maxCount, double _epsilon);
    TermCriteria(const CvTermCriteria& criteria);
    operator CvTermCriteria() const;

    int type;
    int maxCount;
    double epsilon;
};

The class TermCriteria replaces the old CvTermCriteria and fully compatible
with it.

===========================================================================
*cv-Matx*

Template class for small matrices

template<typename T, int m, int n> class Matx
{
public:
    typedef T value_type;
    enum { depth = DataDepth<T>::value, channels = m*n,
           type = CV_MAKETYPE(depth, channels) };

    // various methods
    ...

    Tp val[m*n];
};

typedef Matx<float, 1, 2> Matx12f;
typedef Matx<double, 1, 2> Matx12d;
...
typedef Matx<float, 1, 6> Matx16f;
typedef Matx<double, 1, 6> Matx16d;

typedef Matx<float, 2, 1> Matx21f;
typedef Matx<double, 2, 1> Matx21d;
...
typedef Matx<float, 6, 1> Matx61f;
typedef Matx<double, 6, 1> Matx61d;

typedef Matx<float, 2, 2> Matx22f;
typedef Matx<double, 2, 2> Matx22d;
...
typedef Matx<float, 6, 6> Matx66f;
typedef Matx<double, 6, 6> Matx66d;

The class represents small matrices, which type and size are known at compile
time. If you need more flexible type, use Mat . The elements of a matrix M are
accessible using M(i,j) notation, and most of the common matrix operations (see
also MatrixExpressions ) are available. If you need to do some operation on
Matx that is not implemented, it is easy to convert the matrix to Mat and
backwards.

Matx33f m(1, 2, 3,
          4, 5, 6,
          7, 8, 9);
cout << sum(Mat(m*m.t())) << endl;

===========================================================================
*cv-Vec*

Template class for short numerical vectors

template<typename T, int cn> class Vec : public Matx<T, cn, 1>
{
public:
    typedef T value_type;
    enum { depth = DataDepth<T>::value, channels = cn,
           type = CV_MAKETYPE(depth, channels) };

    // various methods ...
};

typedef Vec<uchar, 2> Vec2b;
typedef Vec<uchar, 3> Vec3b;
typedef Vec<uchar, 4> Vec4b;

typedef Vec<short, 2> Vec2s;
typedef Vec<short, 3> Vec3s;
typedef Vec<short, 4> Vec4s;

typedef Vec<int, 2> Vec2i;
typedef Vec<int, 3> Vec3i;
typedef Vec<int, 4> Vec4i;

typedef Vec<float, 2> Vec2f;
typedef Vec<float, 3> Vec3f;
typedef Vec<float, 4> Vec4f;
typedef Vec<float, 6> Vec6f;

typedef Vec<double, 2> Vec2d;
typedef Vec<double, 3> Vec3d;
typedef Vec<double, 4> Vec4d;
typedef Vec<double, 6> Vec6d;

Vec is a partial case of Matx . It is possible to convert Vec<T,2> to/from
Point_ , Vec<T,3> to/from Point3_ , and Vec<T,4> to CvScalar or Scalar . The
elements of Vec are accessed using operator[] . All the expected vector
operations are implemented too:

  • v1 = v2 \pm v3 , v1 = v2 * \
    alpha , v1 = \alpha * v2 (plus the corresponding
    augmenting operations; note that these operations apply to the each
    computed vector component)
  • v1 == v2, v1 != v2
  • norm(v1) ( L_2 -norm)

The class Vec is commonly used to describe pixel types of multi-channel arrays,
see Mat_ description.

===========================================================================
*cv-Scalar_*

4-element vector

template<typename _Tp> class Scalar_ : public Vec<_Tp, 4>
{
public:
    Scalar_();
    Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);
    Scalar_(const CvScalar& s);
    Scalar_(_Tp v0);
    static Scalar_<_Tp> all(_Tp v0);
    operator CvScalar() const;

    template<typename T2> operator Scalar_<T2>() const;

    Scalar_<_Tp> mul(const Scalar_<_Tp>& t, double scale=1 ) const;
    template<typename T2> void convertTo(T2* buf, int channels, int unroll_to=0) const;
};

typedef Scalar_<double> Scalar;

The template class Scalar_ and it’s double-precision instantiation Scalar
represent 4-element vector. Being derived from Vec<_Tp, 4> , they can be used
as typical 4-element vectors, but in addition they can be converted to/from
CvScalar . The type Scalar is widely used in OpenCV for passing pixel values
and it is a drop-in replacement for CvScalar that was used for the same purpose
in the earlier versions of OpenCV.

===========================================================================
*cv-Range*

Specifies a continuous subsequence (a.k.a. slice) of a sequence.

class Range
{
public:
    Range();
    Range(int _start, int _end);
    Range(const CvSlice& slice);
    int size() const;
    bool empty() const;
    static Range all();
    operator CvSlice() const;

    int start, end;
};

The class is used to specify a row or column span in a matrix ( Mat ), and for
many other purposes. Range(a,b) is basically the same as a:b in Matlab or a..b
in Python. As in Python, start is inclusive left boundary of the range, and end
is exclusive right boundary of the range. Such a half-opened interval is
usually denoted as [start,end) .

The static method Range::all() returns some special variable that means “the
whole sequence” or “the whole range”, just like ” : ” in Matlab or ” ... ” in
Python. All the methods and functions in OpenCV that take Range support this
special Range::all() value, but of course, in the case of your own custom
processing you will probably have to check and handle it explicitly:

void my_function(..., const Range& r, ....)
{
    if(r == Range::all()) {
        // process all the data
    }
    else {
        // process [r.start, r.end)
    }
}

===========================================================================
*cv-Ptr*

A template class for smart reference-counting pointers

template<typename _Tp> class Ptr
{
public:
    // default constructor
    Ptr();
    // constructor that wraps the object pointer
    Ptr(_Tp* _obj);
    // destructor: calls release()
    ~Ptr();
    // copy constructor; increments ptr's reference counter
    Ptr(const Ptr& ptr);
    // assignment operator; decrements own reference counter
    // (with release()) and increments ptr's reference counter
    Ptr& operator = (const Ptr& ptr);
    // increments reference counter
    void addref();
    // decrements reference counter; when it becomes 0,
    // delete_obj() is called
    void release();
    // user-specified custom object deletion operation.
    // by default, "delete obj;" is called
    void delete_obj();
    // returns true if obj == 0;
    bool empty() const;

    // provide access to the object fields and methods
    _Tp* operator -> ();
    const _Tp* operator -> () const;

    // return the underlying object pointer;
    // thanks to the methods, the Ptr<_Tp> can be
    // used instead of _Tp*
    operator _Tp* ();
    operator const _Tp*() const;
protected:
    // the encapsulated object pointer
    _Tp* obj;
    // the associated reference counter
    int* refcount;
};

The class Ptr<_Tp> is a template class that wraps pointers of the corresponding
type. It is similar to shared_ptr that is a part of Boost library ( http://
www.boost.org/doc/libs/1_40_0/libs/smart_ptr/shared_ptr.htm ) and also a part
of the C++0x standard.

By using this class you can get the following capabilities:

  • default constructor, copy constructor and assignment operator for an
    arbitrary C++ class or a C structure. For some objects, like files,
    windows, mutexes, sockets etc, copy constructor or assignment operator are
    difficult to define. For some other objects, like complex classifiers in
    OpenCV, copy constructors are absent and not easy to implement. Finally,
    some of complex OpenCV and your own data structures may have been written
    in C. However, copy constructors and default constructors can simplify
    programming a lot; besides, they are often required (e.g. by STL
    containers). By wrapping a pointer to such a complex object TObj to Ptr
    <TObj> you will automatically get all of the necessary constructors and the
    assignment operator.
  • all the above-mentioned operations running very fast, regardless of the
    data size, i.e. as “O(1)” operations. Indeed, while some structures, like
    std::vector provide a copy constructor and an assignment operator, the
    operations may take considerable time if the data structures are big. But
    if the structures are put into Ptr<> , the overhead becomes small and
    independent of the data size.
  • automatic destruction, even for C structures. See the example below with
    FILE* .
  • heterogeneous collections of objects. The standard STL and most other C++
    and OpenCV containers can only store objects of the same type and the same
    size. The classical solution to store objects of different types in the
    same container is to store pointers to the base class base_class_t*
    instead, but when you loose the automatic memory management. Again, by
    using Ptr<base_class_t>() instead of the raw pointers, you can solve the
    problem.

The class Ptr treats the wrapped object as a black box, the reference counter
is allocated and managed separately. The only thing the pointer class needs to
know about the object is how to deallocate it. This knowledge is incapsulated
in Ptr::delete_obj() method, which is called when the reference counter becomes
0. If the object is a C++ class instance, no additional coding is needed,
because the default implementation of this method calls delete obj; . However,
if the object is deallocated in a different way, then the specialized method
should be created. For example, if you want to wrap FILE , the delete_obj may
be implemented as following:

template<> inline void Ptr<FILE>::delete_obj()
{
    fclose(obj); // no need to clear the pointer afterwards,
                 // it is done externally.
}
...

// now use it:
Ptr<FILE> f(fopen("myfile.txt", "r"));
if(f.empty())
    throw ...;
fprintf(f, ....);
...
// the file will be closed automatically by the Ptr<FILE> destructor.

Note : The reference increment/decrement operations are implemented as atomic
operations, and therefore it is normally safe to use the classes in
multi-threaded applications. The same is true for Mat and other C++ OpenCV
classes that operate on the reference counters.

===========================================================================
*cv-Mat*

OpenCV C++ n-dimensional dense array class.

class CV_EXPORTS Mat
{
public:
    // ... a lot of methods ...
    ...

    /*! includes several bit-fields:
         - the magic signature
         - continuity flag
         - depth
         - number of channels
     */
    int flags;
    //! the array dimensionality, >= 2
    int dims;
    //! the number of rows and columns or (-1, -1) when the array has more than 2 dimensions
    int rows, cols;
    //! pointer to the data
    uchar* data;

    //! pointer to the reference counter;
    // when array points to user-allocated data, the pointer is NULL
    int* refcount;

    // other members
    ...
};

The class Mat represents an n-dimensional dense numerical single-channel or
multi-channel array. It can be used to store real or complex-valued vectors and
matrices, grayscale or color images, voxel volumes, vector fields, point
clouds, tensors, histograms (though, very high-dimensional histograms may be
better stored in a SparseMat ). The data layout of array M is defined by the
array M.step[] , so that the address of element (i_0,...,i_{M.dims-1}) , where
0\leq i_k<M.size[k] is computed as:

addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ... +
M.step[M.dims-1]*i_{M.dims-1}

In the case of 2-dimensional array the above formula is reduced to:

addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j

Note that M.step[i] >= M.step[i+1] (in fact, M.step[i] >= M.step[i+1]*M.size
[i+1] ), that is, 2-dimensional matrices are stored row-by-row, 3-dimensional
matrices are stored plane-by-plane etc. M.step[M.dims-1] is minimal and always
equal to the element size M.elemSize() .

That is, the data layout in Mat is fully compatible with CvMat , IplImage and
CvMatND types from OpenCV 1.x, as well as with majority of dense array types
from the standard toolkits and SDKs, such as Numpy (ndarray), Win32
(independent device bitmaps) etc, i.e. any other array that uses “steps”,
a.k.a. “strides”, to compute position of a pixel. Because of such
compatibility, it is possible to make a Mat header for user-allocated data and
process it in-place using OpenCV functions.

There are many different ways to create Mat object. Here are the some popular
ones:

  • using create(nrows, ncols, type) method or

        the similar constructor

    Mat(nrows, ncols, type[, fillValue]) constructor.

        A new array of the specified size and specifed type will be allocated.

    type has the same meaning as in cvCreateMat() method,

        e.g.

    CV_8UC1 means 8-bit single-channel array,

    CV_32FC2 means 2-channel (i.e. complex) floating-point array etc:

    // make 7x7 complex matrix filled with 1+3j.
    cv::Mat M(7,7,CV_32FC2,Scalar(1,3));
    // and now turn M to 100x60 15-channel 8-bit matrix.
    // The old content will be deallocated
    M.create(100,60,CV_8UC(15));

    As noted in the introduction of this chapter, create() will only allocate a
    new array when the current array shape

        or type are different from the specified.

  • similarly to above, you can create a multi-dimensional array:

    // create 100x100x100 8-bit array
    int sz[] = {100, 100, 100};
    cv::Mat bigCube(3, sz, CV_8U, Scalar::all(0));

    note that it is pass number of dimensions =1 to the Mat constructor, but
    the created array will be 2-dimensional, with the number of columns set to
    1. That’s why Mat::dims is always >= 2 (can also be 0 when the array is
    empty)

  • 
    by using a copy constructor or assignment operator, where on the right side
        it can

        be a array or expression, see below. Again, as noted in the
        introduction, array assignment is O(1) operation because it only copies
        the header and increases the reference counter.

    Mat::clone() method can be used to get a full

        (a.k.a. deep) copy of the array when you need it.

  • 
    by constructing a header for a part of another array. It can be a single
        row, single column,

        several rows, several columns, rectangular region in the array (called
        a minor in algebra) or a diagonal. Such operations are also O(1),
        because the new header will reference the same data. You can actually
        modify a part of the array using this feature, e.g.

    // add 5-th row, multiplied by 3 to the 3rd row
    M.row(3) = M.row(3) + M.row(5)*3;

    // now copy 7-th column to the 1-st column
    // M.col(1) = M.col(7); // this will not work
    Mat M1 = M.col(1);
    M.col(7).copyTo(M1);

    // create new 320x240 image
    cv::Mat img(Size(320,240),CV_8UC3);
    // select a roi
    cv::Mat roi(img, Rect(10,10,100,100));
    // fill the ROI with (0,255,0) (which is green in RGB space);
    // the original 320x240 image will be modified
    roi = Scalar(0,255,0);

    Thanks to the additional datastart and dataend members, it is possible to

        compute the relative sub-array position in the main

    “container” array using locateROI() :

    Mat A = Mat::eye(10, 10, CV_32S);
    // extracts A columns, 1 (inclusive) to 3 (exclusive).
    Mat B = A(Range::all(), Range(1, 3));
    // extracts B rows, 5 (inclusive) to 9 (exclusive).
    // that is, C ~ A(Range(5, 9), Range(1, 3))
    Mat C = B(Range(5, 9), Range::all());
    Size size; Point ofs;
    C.locateROI(size, ofs);
    // size will be (width=10,height=10) and the ofs will be (x=1, y=5)

    As in the case of whole matrices, if you need a deep copy, use clone()
    method

        of the extracted sub-matrices.

  • by making a header for user-allocated-data. It can be useful for

     1.
        processing “foreign” data using OpenCV (e.g. when you implement

            a DirectShow filter or a processing module for gstreamer etc.),
            e.g.

        void process_video_frame(const unsigned char* pixels,
                                 int width, int height, int step)
        {
            cv::Mat img(height, width, CV_8UC3, pixels, step);
            cv::GaussianBlur(img, img, cv::Size(7,7), 1.5, 1.5);
        }

     2. for quick initialization of small matrices and/or super-fast element
        access

        double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};
        cv::Mat M = cv::Mat(3, 3, CV_64F, m).inv();

    partial yet very common cases of this “user-allocated data” case are
        conversions

        from

    CvMat and IplImage to Mat . For this purpose there are special constructors

        taking pointers to

    CvMat or IplImage and the optional

        flag indicating whether to copy the data or not.

        Backward conversion from

    Mat to CvMat or IplImage is provided via cast operators

    Mat::operator CvMat() const an Mat::operator IplImage() .

        The operators do

    not copy the data.

    IplImage* img = cvLoadImage("greatwave.jpg", 1);
    Mat mtx(img); // convert IplImage* -> cv::Mat
    CvMat oldmat = mtx; // convert cv::Mat -> CvMat
    CV_Assert(oldmat.cols == img->width && oldmat.rows == img->height &&
        oldmat.data.ptr == (uchar*)img->imageData && oldmat.step == img->widthStep);

  • by using MATLAB-style array initializers, zeros(), ones(), eye() , e.g.:

    // create a double-precision identity martix and add it to M.
    M += Mat::eye(M.rows, M.cols, CV_64F);

  • by using comma-separated initializer:

    // create 3x3 double-precision identity matrix
    Mat M = (Mat_<double>(3,3) << 1, 0, 0, 0, 1, 0, 0, 0, 1);

    here we first call constructor of Mat_ class (that we describe further)
    with the proper parameters, and then we just put << operator followed by
    comma-separated values that can be constants, variables, expressions etc.
    Also, note the extra parentheses that are needed to avoid compiler errors.

Once array is created, it will be automatically managed by using
reference-counting mechanism (unless the array header is built on top of
user-allocated data, in which case you should handle the data by yourself). The
array data will be deallocated when no one points to it; if you want to release
the data pointed by a array header before the array destructor is called, use
Mat::release() .

The next important thing to learn about the array class is element access.
Earlier it was shown how to compute address of each array element. Normally,
it’s not needed to use the formula directly in your code. If you know the array
element type (which can be retrieved using the method Mat::type() ), you can
access element M_{ij} of 2-dimensional array as:

M.at<double>(i,j) += 1.f;

assuming that M is double-precision floating-point array. There are several
variants of the method at for different number of dimensions.

If you need to process a whole row of a 2d array, the most efficient way is to
get the pointer to the row first, and then just use plain C operator [] :

// compute sum of positive matrix elements
// (assuming that M is double-precision matrix)
double sum=0;
for(int i = 0; i < M.rows; i++)
{
    const double* Mi = M.ptr<double>(i);
    for(int j = 0; j < M.cols; j++)
        sum += std::max(Mi[j], 0.);
}

Some operations, like the above one, do not actually depend on the array shape,
they just process elements of an array one by one (or elements from multiple
arrays that have the same coordinates, e.g. array addition). Such operations
are called element-wise and it makes sense to check whether all the input/
output arrays are continuous, i.e. have no gaps in the end of each row, and if
yes, process them as a single long row:

// compute sum of positive matrix elements, optimized variant
double sum=0;
int cols = M.cols, rows = M.rows;
if(M.isContinuous())
{
    cols *= rows;
    rows = 1;
}
for(int i = 0; i < rows; i++)
{
    const double* Mi = M.ptr<double>(i);
    for(int j = 0; j < cols; j++)
        sum += std::max(Mi[j], 0.);
}

in the case of continuous matrix the outer loop body will be executed just
once, so the overhead will be smaller, which will be especially noticeable in
the case of small matrices.

Finally, there are STL-style iterators that are smart enough to skip gaps
between successive rows:

// compute sum of positive matrix elements, iterator-based variant
double sum=0;
MatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();
for(; it != it_end; ++it)
    sum += std::max(*it, 0.);

The matrix iterators are random-access iterators, so they can be passed to any
STL algorithm, including std::sort() .

Matrix Expressions~

This is a list of implemented matrix operations that can be combined in
arbitrary complex expressions (here A , B stand for matrices ( Mat ), s for a
scalar ( Scalar ), \alpha for a real-valued scalar ( double )):

  • addition, subtraction, negation: A \pm B,\;A \pm s,\;s \pm A,\;-A

  • scaling: A*\alpha , A*\alpha

  • per-element multiplication and division: A.mul(B), A/B, \alpha/A

  • matrix multiplication: A*B

  • transposition: A.t() \sim A^t

  • matrix inversion and pseudo-inversion, solving linear systems and
    least-squares problems:

    A.inv([method]) \sim A^{-1}, A.inv([method])*B \sim X:\,AX=B

  • comparison: A\gtreqqless B,\;A \ne B,\;A \gtreqqless \alpha,\;A \ne \alpha
    .

        The result of comparison is 8-bit single channel mask, which elements
        are set to 255 (if the particular element or pair of elements satisfy
        the condition) and 0 otherwise.

  • bitwise logical operations: A & B, A & s, A | B, A | s, A textasciicircum
    B, A textasciicircum s, ~ A

  • element-wise minimum and maximum: min(A, B), min(A, \alpha), max(A, B), max
    (A, \alpha)

  • element-wise absolute value: abs(A)

  • cross-product, dot-product: A.cross(B), A.dot(B)

  • any function of matrix or matrices and scalars that returns a matrix or a
    scalar, such as

    norm() , mean() , sum() , countNonZero() , trace() ,

    determinant() , repeat() etc.

  • matrix initializers ( eye(), zeros(), ones() ), matrix comma-separated
    initializers,

        matrix constructors and operators that extract sub-matrices (see

    Mat description).

  • verb “Mat_<destination_type>()” constructors to cast the result to the
    proper type.

Note, however, that comma-separated initializers and probably some other
operations may require additional explicit Mat() or verb “Mat_<T>()” constuctor
calls to resolve possible ambiguity.

Below is the formal description of the Mat methods.

===========================================================================
*cv-Mat::Mat*

(1) Mat::Mat()

(2) Mat::Mat(int rows, int cols, int type)

(3) Mat::Mat(Size size, int type)

(4) Mat::Mat(int rows, int cols, int type, const Scalar& s)

(5) Mat::Mat(Size size, int type, const Scalar& s)

(6) Mat::Mat(const Mat& m)

(7) Mat::Mat(int rows, int cols, int type, void* data, size_t step=AUTO_STEP)

(8) Mat::Mat(Size size, int type, void* data, size_t step=AUTO_STEP)

(9) Mat::Mat(const Mat& m, const Range& rowRange, const Range& colRange)

(10) Mat::Mat(const Mat& m, const Rect& roi)

(11) Mat::Mat(const CvMat* m, bool copyData=false)

(12) Mat::Mat(const IplImage* img, bool copyData=false)

(13) template<typename T, int n> explicit Mat::Mat(const Vec<T, n>& vec, bool
    copyData=true)

(14) template<typename T, int m, int n> explicit Mat::Mat(const Matx<T, m, n>&
    vec, bool copyData=true)

(15) template<typename T> explicit Mat::Mat(const vector<T>& vec, bool copyData
    =false)

(16) Mat::Mat(const MatExpr& expr)

(17) Mat::Mat(int ndims, const int* sizes, int type)

(18) Mat::Mat(int ndims, const int* sizes, int type, const Scalar& s)

(19) Mat::Mat(int ndims, const int* sizes, int type, void* data, const size_t*
    steps=0)

(20) Mat::Mat(const Mat& m, const Range* ranges)

    Various array constructors

                  • ndims – The array dimensionality
                  • rows – The number of rows in 2D array
                  • cols – The number of columns in 2D array
                  • size – The 2D array size: Size(cols, rows) . Note that in
                    the Size() constructor the number of rows and the number of
                    columns go in the reverse order.
                  • sizes – The array of integers, specifying the n-dimensional
                    array shape
                  • type – The array type, use CV_8UC1, ..., CV_64FC4 to create
                    1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to
                    create multi-channel (up to CV_MAX_CN channels) matrices
                  • s – The optional value to initialize each matrix element
                    with. To set all the matrix elements to the particular
                    value after the construction, use the assignment operator
                    Mat::operator=(const Scalar& value) .
                  • data – Pointer to the user data. Matrix constructors that
                    take data and step parameters do not allocate matrix data.
                    Instead, they just initialize the matrix header that points
                    to the specified data, i.e. no data is copied. This
                    operation is very efficient and can be used to process
                    external data using OpenCV functions. The external data is
                    not automatically deallocated, user should take care of it.
                  • step – The data buddy. This optional parameter specifies
                    the number of bytes that each matrix row occupies. The
                    value should include the padding bytes in the end of each
                    row, if any. If the parameter is missing (set to
                    cv::AUTO_STEP ), no padding is assumed and the actual step
                    is calculated as cols*elemSize() , see Mat::elemSize ().
                  • steps – The array of ndims-1 steps in the case of
                    multi-dimensional array (the last step is always set to the
                    element size). If not specified, the matrix is assumed to
                    be continuous.
                  • m – The array that (in whole, a partly) is assigned to the
                    constructed matrix. No data is copied by these
                    constructors. Instead, the header pointing to m data, or
                    its sub-array, is constructed and the associated with it
                    reference counter, if any, is incremented. That is, when
    Parameters:     you modify the matrix formed using such a constructor, you
                    will also modify the corresponding elements of m . If you
                    want to have an independent copy of the sub-array, use
                    Mat::clone() .
                  • img – Pointer to the old-style IplImage image structure. By
                    default, the data is shared between the original image and
                    the new matrix, but when copyData is set, the full copy of
                    the image data is created.
                  • vec – STL vector, which elements will form the matrix. The
                    matrix will have a single column and the number of rows
                    equal to the number of vector elements. Type of the matrix
                    will match the type of vector elements. The constructor can
                    handle arbitrary types, for which there is properly
                    declared DataType , i.e. the vector elements must be
                    primitive numbers or uni-type numerical tuples of numbers.
                    Mixed-type structures are not supported, of course. Note
                    that the corresponding constructor is explicit, meaning
                    that STL vectors are not automatically converted to Mat
                    instances, you should write Mat(vec) explicitly. Another
                    obvious note: unless you copied the data into the matrix (
                    copyData=true ), no new elements should be added to the
                    vector, because it can potentially yield vector data
                    reallocation, and thus the matrix data pointer will become
                    invalid.
                  • copyData – Specifies, whether the underlying data of the
                    STL vector, or the old-style CvMat or IplImage should be
                    copied to (true) or shared with (false) the newly
                    constructed matrix. When the data is copied, the allocated
                    buffer will be managed using Mat ‘s reference counting
                    mechanism. While when the data is shared, the reference
                    counter will be NULL, and you should not deallocate the
                    data until the matrix is not destructed.
                  • rowRange – The range of the m ‘s rows to take. As usual,
                    the range start is inclusive and the range end is
                    exclusive. Use Range::all() to take all the rows.
                  • colRange – The range of the m ‘s columns to take. Use
                    Range::all() to take all the columns.
                  • ranges – The array of selected ranges of m along each
                    dimensionality

    .

    Parameter: expr – Matrix expression. See Matrix Expressions .

These are various constructors that form a matrix. As noticed in the , often
the default constructor is enough, and the proper matrix will be allocated by
an OpenCV function. The constructed matrix can further be assigned to another
matrix or matrix expression, in which case the old content is dereferenced, or
be allocated with Mat::create .

===========================================================================
*cv-Mat::Mat2*

Mat::~Mat()¶
    Matrix destructor

The matrix destructor calls Mat::release .

cv::Mat::operator =~

Mat& Mat::operator = (const Mat& m)

Mat& Mat::operator = (const MatExpr_Base& expr)

Mat& operator = (const Scalar& s)

    Matrix assignment operators

                  • m – The assigned, right-hand-side matrix. Matrix assignment
                    is O(1) operation, that is, no data is copied. Instead, the
                    data is shared and the reference counter, if any, is
                    incremented. Before assigning new data, the old data is
                    dereferenced via Mat::release .
                  • expr – The assigned matrix expression object. As opposite
                    to the first form of assignment operation, the second form
    Parameters:     can reuse already allocated matrix if it has the right size
                    and type to fit the matrix expression result. It is
                    automatically handled by the real function that the matrix
                    expressions is expanded to. For example, C=A+B is expanded
                    to cv::add(A, B, C) , and add() will take care of automatic
                    C reallocation.
                  • s – The scalar, assigned to each matrix element. The matrix
                    size or type is not changed.

These are the available assignment operators, and they all are very different,
so, please, look at the operator parameters description.

cv::Mat::operator MatExpr~

Mat::operator MatExpr_<Mat, Mat>() const
    Mat-to-MatExpr cast operator

The cast operator should not be called explicitly. It is used internally by the
Matrix Expressions engine.

===========================================================================
*cv-Mat::row*

Mat Mat::row(int i) const~

    Makes a matrix header for the specified matrix row

    Parameter: i – the 0-based row index

The method makes a new header for the specified matrix row and returns it. This
is O(1) operation, regardless of the matrix size. The underlying data of the
new matrix will be shared with the original matrix. Here is the example of one
of the classical basic matrix processing operations, axpy, used by LU and many
other algorithms:

inline void matrix_axpy(Mat& A, int i, int j, double alpha)
{
    A.row(i) += A.row(j)*alpha;
}

Important note . In the current implementation the following code will not work
as expected:

Mat A;
...
A.row(i) = A.row(j); // will not work

This is because A.row(i) forms a temporary header, which is further assigned
another header. Remember, each of these operations is O(1), i.e. no data is
copied. Thus, the above assignment will have absolutely no effect, while you
may have expected j-th row being copied to i-th row. To achieve that, you
should either turn this simple assignment into an expression, or use
Mat::copyTo method:

Mat A;
...
// works, but looks a bit obscure.
A.row(i) = A.row(j) + 0;

// this is a bit longer, but the recommended method.
Mat Ai = A.row(i); M.row(j).copyTo(Ai);

===========================================================================
*cv-Mat::col*

Mat Mat::col(int j) const~

    Makes a matrix header for the specified matrix column

    Parameter: j – the 0-based column index

The method makes a new header for the specified matrix column and returns it.
This is O(1) operation, regardless of the matrix size. The underlying data of
the new matrix will be shared with the original matrix. See also Mat::row
description.

===========================================================================
*cv-Mat::rowRange*

Mat Mat::rowRange(int startrow, int endrow) const~

Mat Mat::rowRange(const Range& r) const

    Makes a matrix header for the specified row span

                  • startrow – the 0-based start index of the row span
    Parameters:   • endrow – the 0-based ending index of the row span
                  • r – The Range() structure containing both the start and the
                    end indices

The method makes a new header for the specified row span of the matrix.
Similarly to Mat::row() and Mat::col() , this is O(1) operation.

===========================================================================
*cv-Mat::colRange*

Mat Mat::colRange(int startcol, int endcol) const~

Mat Mat::colRange(const Range& r) const

    Makes a matrix header for the specified row span

                  • startcol – the 0-based start index of the column span
    Parameters:   • endcol – the 0-based ending index of the column span
                  • r – The Range() structure containing both the start and the
                    end indices

The method makes a new header for the specified column span of the matrix.
Similarly to Mat::row() and Mat::col() , this is O(1) operation.

===========================================================================
*cv-Mat::diag*

Mat Mat::diag(int d) const static Mat Mat::diag(const Mat& matD)~

    Extracts diagonal from a matrix, or creates a diagonal matrix.

                  • d –

                    index of the diagonal, with the following meaning:

                      □ d=0 the main diagonal
    Parameters:       □ d>0 a diagonal from the lower half, e.g. d=1 means the
                        diagonal immediately below the main one
                      □ d<0 a diagonal from the upper half, e.g. d=1 means the
                        diagonal immediately above the main one
                  • matD – single-column matrix that will form the diagonal
                    matrix.

The method makes a new header for the specified matrix diagonal. The new matrix
will be represented as a single-column matrix. Similarly to Mat::row() and
Mat::col() , this is O(1) operation.

===========================================================================
*cv-Mat::clone*

Mat Mat::clone() const¶
    Creates full copy of the array and the underlying data.

The method creates full copy of the array. The original step[] are not taken
into the account. That is, the array copy will be a continuous array occupying
total()*elemSize() bytes.

===========================================================================
*cv-Mat::copyTo*

void Mat::copyTo(Mat& m ) const void Mat::copyTo( Mat& m, const Mat& mask)
    const~

    Copies the matrix to another one.

                  • m – The destination matrix. If it does not have a proper
    Parameters:     size or type before the operation, it will be reallocated
                  • mask – The operation mask. Its non-zero elements indicate,
                    which matrix elements need to be copied

The method copies the matrix data to another matrix. Before copying the data,
the method invokes

m.create(this->size(), this->type);

so that the destination matrix is reallocated if needed. While m.copyTo(m);
will work as expected, i.e. will have no effect, the function does not handle
the case of a partial overlap between the source and the destination matrices.

When the operation mask is specified, and the Mat::create call shown above
reallocated the matrix, the newly allocated matrix is initialized with all 0’s
before copying the data.

===========================================================================
*cv-Mat::convertTo*

void Mat::convertTo(Mat& m, int rtype, double alpha=1, double beta=0) const~

    Converts array to another datatype with optional scaling.

                  • m – The destination matrix. If it does not have a proper
                    size or type before the operation, it will be reallocated
                  • rtype – The desired destination matrix type, or rather, the
    Parameters:     depth (since the number of channels will be the same with
                    the source one). If rtype is negative, the destination
                    matrix will have the same type as the source.
                  • alpha – The optional scale factor
                  • beta – The optional delta, added to the scaled values.

The method converts source pixel values to the target datatype. saturate_cast<>
is applied in the end to avoid possible overflows:

m(x,y) = saturate \_ cast<rType>( \alpha (*this)(x,y) + \beta )

===========================================================================
*cv-Mat::assignTo*

void Mat::assignTo(Mat& m, int type=-1) const~

    Functional form of convertTo

                  • m – The destination array
    Parameters:   • type – The desired destination array depth (or -1 if it
                    should be the same as the source one).

This is internal-use method called by the Matrix Expressions engine.

===========================================================================
*cv-Mat::setTo*

Mat& Mat::setTo(const Scalar& s, const Mat& mask=Mat())~

    Sets all or some of the array elements to the specified value.

                  • s – Assigned scalar, which is converted to the actual array
    Parameters:     type
                  • mask – The operation mask of the same size as *this

This is the advanced variant of Mat::operator=(const Scalar& s) operator.

===========================================================================
*cv-reshape*

Mat Mat::reshape(int cn, int rows=0) const~

    Changes the 2D matrix’s shape and/or the number of channels without copying
    the data.

                  • cn – The new number of channels. If the parameter is 0, the
    Parameters:     number of channels remains the same.
                  • rows – The new number of rows. If the parameter is 0, the
                    number of rows remains the same.

The method makes a new matrix header for *this elements. The new matrix may
have different size and/or different number of channels. Any combination is
possible, as long as:

 1.
    No extra elements is included into the new matrix and no elements are
        excluded. Consequently,

        the product

    rows*cols*channels() must stay the same after the transformation.

 2. No data is copied, i.e. this is O(1) operation. Consequently, if you change
    the number of rows, or the operation changes elements’ row indices in some
    other way, the matrix must be continuous. See Mat::isContinuous() .

Here is some small example. Assuming, there is a set of 3D points that are
stored as STL vector, and you want to represent the points as 3xN matrix. Here
is how it can be done:

std::vector<cv::Point3f> vec;
...

Mat pointMat = Mat(vec). // convert vector to Mat, O(1) operation
                  reshape(1). // make Nx3 1-channel matrix out of Nx1 3-channel.
                              // Also, an O(1) operation
                     t(); // finally, transpose the Nx3 matrix.
                          // This involves copying of all the elements

cv::Mat::t()~

MatExpr Mat::t() const¶
    Transposes the matrix

The method performs matrix transposition by means of matrix expressions. It
does not perform the actual transposition, but returns a temporary “matrix
transposition” object that can be further used as a part of more complex matrix
expression or be assigned to a matrix:

Mat A1 = A + Mat::eye(A.size(), A.type)*lambda;
Mat C = A1.t()*A1; // compute (A + lambda*I)^t * (A + lamda*I)

===========================================================================
*cv-Mat::inv*

MatExpr Mat::inv(int method=DECOMP_LU) const~

    Inverses the matrix

               method –

               The matrix inversion method, one of

    Parameter:   • DECOMP_LU LU decomposition. The matrix must be non-singular
                 • DECOMP_CHOLESKY Cholesky LL^T decomposition, for symmetrical
                   positively defined matrices only. About twice faster than LU
                   on big matrices.
                 • DECOMP_SVD SVD decomposition. The matrix can be a singular
                   or even non-square, then the pseudo-inverse is computed

The method performs matrix inversion by means of matrix expressions, i.e. a
temporary “matrix inversion” object is returned by the method, and can further
be used as a part of more complex matrix expression or be assigned to a matrix.

===========================================================================
*cv-Mat::mul*

MatExpr Mat::mul(const Mat& m, double scale=1) const~

MatExpr Mat::mul(const MatExpr& m, double scale=1) const

    Performs element-wise multiplication or division of the two matrices

                  • m – Another matrix, of the same type and the same size as
    Parameters:     *this , or a matrix expression
                  • scale – The optional scale factor

The method returns a temporary object encoding per-element array
multiplication, with optional scale. Note that this is not a matrix
multiplication, which corresponds to a simpler “*” operator.

Here is a example:

Mat C = A.mul(5/B); // equivalent to divide(A, B, C, 5)

===========================================================================
*cv-Mat::cross*

Mat Mat::cross(const Mat& m) const~

    Computes cross-product of two 3-element vectors

    Parameter: m – Another cross-product operand

The method computes cross-product of the two 3-element vectors. The vectors
must be 3-elements floating-point vectors of the same shape and the same size.
The result will be another 3-element vector of the same shape and the same type
as operands.

===========================================================================
*cv-Mat::dot*

double Mat::dot(const Mat& m) const~

    Computes dot-product of two vectors

    Parameter: m – Another dot-product operand.

The method computes dot-product of the two matrices. If the matrices are not
single-column or single-row vectors, the top-to-bottom left-to-right scan
ordering is used to treat them as 1D vectors. The vectors must have the same
size and the same type. If the matrices have more than one channel, the dot
products from all the channels are summed together.

===========================================================================
*cv-Mat::zeros*

static MatExpr Mat::zeros(int rows, int cols, int type) static MatExpr Mat
    ::zeros(Size size, int type) static MatExpr Mat::zeros(int ndims, const
    int* sizes, int type)~

    Returns zero array of the specified size and type

                  • ndims – The array dimensionality
                  • rows – The number of rows
                  • cols – The number of columns
    Parameters:   • size – Alternative matrix size specification: Size(cols,
                    rows)
                  • sizes – The array of integers, specifying the array shape
                  • type – The created matrix type

The method returns Matlab-style zero array initializer. It can be used to
quickly form a constant array and use it as a function parameter, as a part of
matrix expression, or as a matrix initializer.

Mat A;
A = Mat::zeros(3, 3, CV_32F);

Note that in the above sample a new matrix will be allocated only if A is not
3x3 floating-point matrix, otherwise the existing matrix A will be filled with
0’s.

===========================================================================
*cv-Mat::ones*

static MatExpr Mat::ones(int rows, int cols, int type) static MatExpr Mat::ones
    (Size size, int type) static MatExpr Mat::ones(int ndims, const int* sizes,
    int type)~

    Returns array of all 1’s of the specified size and type

                  • ndims – The array dimensionality
                  • rows – The number of rows
                  • cols – The number of columns
    Parameters:   • size – Alternative matrix size specification: Size(cols,
                    rows)
                  • sizes – The array of integers, specifying the array shape
                  • type – The created matrix type

The method returns Matlab-style ones’ array initializer, similarly to
Mat::zeros() . Note that using this method you can initialize an array with
arbitrary value, using the following Matlab idiom:

Mat A = Mat::ones(100, 100, CV_8U)*3; // make 100x100 matrix filled with 3.

The above operation will not form 100x100 matrix of ones and then multiply it
by 3. Instead, it will just remember the scale factor (3 in this case) and use
it when actually invoking the matrix initializer.

===========================================================================
*cv-Mat::eye*

static MatExpr Mat::eye(int rows, int cols, int type) static MatExpr Mat::eye
    (Size size, int type)~

    Returns identity matrix of the specified size and type

                  • rows – The number of rows
                  • cols – The number of columns
    Parameters:   • size – Alternative matrix size specification: Size(cols,
                    rows)
                  • type – The created matrix type

The method returns Matlab-style identity matrix initializer, similarly to
Mat::zeros() . Similarly to Mat::ones , you can use a scale operation to create
a scaled identity matrix efficiently:

// make a 4x4 diagonal matrix with 0.1's on the diagonal.
Mat A = Mat::eye(4, 4, CV_32F)*0.1;

===========================================================================
*cv-Mat::create*

void Mat::create(int rows, int cols, int type) void Mat::create(Size size, int
    type) void Mat::create(int ndims, const int* sizes, int type)~

    Allocates new array data if needed.

                  • ndims – The new array dimensionality
                  • rows – The new number of rows
                  • cols – The new number of columns
    Parameters:   • size – Alternative new matrix size specification: Size
                    (cols, rows)
                  • sizes – The array of integers, specifying the new array
                    shape
                  • type – The new matrix type

This is one of the key Mat methods. Most new-style OpenCV functions and methods
that produce arrays call this method for each output array. The method uses the
following algorithm:

 1. if the current array shape and the type match the new ones, return
    immediately.
 2. otherwise, dereference the previous data by calling Mat::release()
 3. initialize the new header
 4. allocate the new data of total()*elemSize() bytes
 5. allocate the new, associated with the data, reference counter and set it to
    1.

Such a scheme makes the memory management robust and efficient at the same
time, and also saves quite a bit of typing for the user, i.e. usually there is
no need to explicitly allocate output arrays. That is, instead of writing:

Mat color;
...
Mat gray(color.rows, color.cols, color.depth());
cvtColor(color, gray, CV_BGR2GRAY);

you can simply write:

Mat color;
...
Mat gray;
cvtColor(color, gray, CV_BGR2GRAY);

because cvtColor , as well as most of OpenCV functions, calls Mat::create() for
the output array internally.

===========================================================================
*cv-Mat::addref*

void Mat::addref()¶
    Increments the reference counter

The method increments the reference counter, associated with the matrix data.
If the matrix header points to an external data (see Mat::Mat() ), the
reference counter is NULL, and the method has no effect in this case. Normally,
the method should not be called explicitly, to avoid memory leaks. It is called
implicitly by the matrix assignment operator. The reference counter increment
is the atomic operation on the platforms that support it, thus it is safe to
operate on the same matrices asynchronously in different threads.

===========================================================================
*cv-Mat::release*

void Mat::release()¶
    Decrements the reference counter and deallocates the matrix if needed

The method decrements the reference counter, associated with the matrix data.
When the reference counter reaches 0, the matrix data is deallocated and the
data and the reference counter pointers are set to NULL’s. If the matrix header
points to an external data (see Mat::Mat() ), the reference counter is NULL,
and the method has no effect in this case.

This method can be called manually to force the matrix data deallocation. But
since this method is automatically called in the destructor, or by any other
method that changes the data pointer, it is usually not needed. The reference
counter decrement and check for 0 is the atomic operation on the platforms that
support it, thus it is safe to operate on the same matrices asynchronously in
different threads.

===========================================================================
*cv-Mat::resize*

void Mat::resize(size_t sz) const~

    Changes the number of matrix rows

    Parameter: sz – The new number of rows

The method changes the number of matrix rows. If the matrix is reallocated, the
first min(Mat::rows, sz) rows are preserved. The method emulates the
corresponding method of STL vector class.

===========================================================================
*cv-Mat::push_back*

template<typename T> void Mat::push_back(const T& elem) template<typename T>
    void Mat::push_back(const Mat_<T>& elem)~

    Adds elements to the bottom of the matrix

    Parameter: elem – The added element(s).

The methods add one or more elements to the bottom of the matrix. They emulate
the corresponding method of STL vector class. When elem is Mat , its type and
the number of columns must be the same as in the container matrix.

===========================================================================
*cv-Mat::pop_back*

template<typename T> void Mat::pop_back(size_t nelems=1)~

    Removes elements from the bottom of the matrix.

    Parameter: nelems – The number of rows removed. If it is greater than the
               total number of rows, an exception is thrown.

The method removes one or more rows from the bottom of the matrix.

===========================================================================
*cv-Mat::locateROI*

void Mat::locateROI(Size& wholeSize, Point& ofs) const~

    Locates matrix header within a parent matrix

                  • wholeSize – The output parameter that will contain size of
    Parameters:     the whole matrix, which *this is a part of.
                  • ofs – The output parameter that will contain offset of
                    *this inside the whole matrix

After you extracted a submatrix from a matrix using Mat::row() , Mat::col() ,
Mat::rowRange() , Mat::colRange() etc., the result submatrix will point just to
the part of the original big matrix. However, each submatrix contains some
information (represented by datastart and dataend fields), using which it is
possible to reconstruct the original matrix size and the position of the
extracted submatrix within the original matrix. The method locateROI does
exactly that.

===========================================================================
*cv-Mat::adjustROI*

Mat& Mat::adjustROI(int dtop, int dbottom, int dleft, int dright)~

    Adjust submatrix size and position within the parent matrix

                  • dtop – The shift of the top submatrix boundary upwards
                  • dbottom – The shift of the bottom submatrix boundary
                    downwards
    Parameters:   • dleft – The shift of the left submatrix boundary to the
                    left
                  • dright – The shift of the right submatrix boundary to the
                    right

The method is complimentary to the Mat::locateROI() . Indeed, the typical use
of these functions is to determine the submatrix position within the parent
matrix and then shift the position somehow. Typically it can be needed for
filtering operations, when pixels outside of the ROI should be taken into
account. When all the method’s parameters are positive, it means that the ROI
needs to grow in all directions by the specified amount, i.e.

A.adjustROI(2, 2, 2, 2);

increases the matrix size by 4 elements in each direction and shifts it by 2
elements to the left and 2 elements up, which brings in all the necessary
pixels for the filtering with 5x5 kernel.

It’s user responsibility to make sure that adjustROI does not cross the parent
matrix boundary. If it does, the function will signal an error.

The function is used internally by the OpenCV filtering functions, like
filter2D() , morphological operations etc.

See also copyMakeBorder() .

cv::Mat::operator()~

Mat Mat::operator()( Range rowRange, Range colRange) const~

Mat Mat::operator()( const Rect& roi ) const Mat Mat::operator()( const Ranges*
    ranges) const

    Extracts a rectangular submatrix

                  • rowRange – The start and the end row of the extracted
                    submatrix. The upper boundary is not included. To select
                    all the rows, use Range::all()
                  • colRange – The start and the end column of the extracted
    Parameters:     submatrix. The upper boundary is not included. To select
                    all the columns, use Range::all()
                  • roi – The extracted submatrix specified as a rectangle
                  • ranges – The array of selected ranges along each array
                    dimension

The operators make a new header for the specified sub-array of *this . They are
the most generalized forms of Mat::row() , Mat::col() , Mat::rowRange() and
Mat::colRange() . For example, A(Range(0, 10), Range::all()) is equivalent to
A.rowRange(0, 10) . Similarly to all of the above, the operators are O(1)
operations, i.e. no matrix data is copied.

cv::Mat::operator CvMat~

Mat::operator CvMat() const¶
    Creates CvMat header for the matrix

The operator makes CvMat header for the matrix without copying the underlying
data. The reference counter is not taken into account by this operation, thus
you should make sure than the original matrix is not deallocated while the
CvMat header is used. The operator is useful for intermixing the new and the
old OpenCV API’s, e.g:

Mat img(Size(320, 240), CV_8UC3);
...

CvMat cvimg = img;
mycvOldFunc( &cvimg, ...);

where mycvOldFunc is some function written to work with OpenCV 1.x data
structures.

cv::Mat::operator IplImage~

Mat::operator IplImage() const¶
    Creates IplImage header for the matrix

The operator makes IplImage header for the matrix without copying the
underlying data. You should make sure than the original matrix is not
deallocated while the IplImage header is used. Similarly to Mat::operator CvMat
, the operator is useful for intermixing the new and the old OpenCV API’s.

===========================================================================
*cv-Mat::total*

size_t Mat::total() const¶
    Returns the total number of array elements.

The method returns the number of array elements (e.g. number of pixels if the
array represents an image).

===========================================================================
*cv-Mat::isContinuous*

bool Mat::isContinuous() const¶
    Reports whether the matrix is continuous or not

The method returns true if the matrix elements are stored continuously, i.e.
without gaps in the end of each row, and false otherwise. Obviously, 1x1 or 1xN
matrices are always continuous. Matrices created with Mat::create() are always
continuous, but if you extract a part of the matrix using Mat::col() ,
Mat::diag() etc. or constructed a matrix header for externally allocated data,
such matrices may no longer have this property.

The continuity flag is stored as a bit in Mat::flags field, and is computed
automatically when you construct a matrix header, thus the continuity check is
very fast operation, though it could be, in theory, done as following:

// alternative implementation of Mat::isContinuous()
bool myCheckMatContinuity(const Mat& m)
{
    //return (m.flags & Mat::CONTINUOUS_FLAG) != 0;
    return m.rows == 1 || m.step == m.cols*m.elemSize();
}

The method is used in a quite a few of OpenCV functions, and you are welcome to
use it as well. The point is that element-wise operations (such as arithmetic
and logical operations, math functions, alpha blending, color space
transformations etc.) do not depend on the image geometry, and thus, if all the
input and all the output arrays are continuous, the functions can process them
as very long single-row vectors. Here is the example of how alpha-blending
function can be implemented.

template<typename T>
void alphaBlendRGBA(const Mat& src1, const Mat& src2, Mat& dst)
{
    const float alpha_scale = (float)std::numeric_limits<T>::max(),
                inv_scale = 1.f/alpha_scale;

    CV_Assert( src1.type() == src2.type() &&
               src1.type() == CV_MAKETYPE(DataType<T>::depth, 4) &&
               src1.size() == src2.size());
    Size size = src1.size();
    dst.create(size, src1.type());

    // here is the idiom: check the arrays for continuity and,
    // if this is the case,
    // treat the arrays as 1D vectors
    if( src1.isContinuous() && src2.isContinuous() && dst.isContinuous() )
    {
        size.width *= size.height;
        size.height = 1;
    }
    size.width *= 4;

    for( int i = 0; i < size.height; i++ )
    {
        // when the arrays are continuous,
        // the outer loop is executed only once
        const T* ptr1 = src1.ptr<T>(i);
        const T* ptr2 = src2.ptr<T>(i);
        T* dptr = dst.ptr<T>(i);

        for( int j = 0; j < size.width; j += 4 )
        {
            float alpha = ptr1[j+3]*inv_scale, beta = ptr2[j+3]*inv_scale;
            dptr[j] = saturate_cast<T>(ptr1[j]*alpha + ptr2[j]*beta);
            dptr[j+1] = saturate_cast<T>(ptr1[j+1]*alpha + ptr2[j+1]*beta);
            dptr[j+2] = saturate_cast<T>(ptr1[j+2]*alpha + ptr2[j+2]*beta);
            dptr[j+3] = saturate_cast<T>((1 - (1-alpha)*(1-beta))*alpha_scale);
        }
    }
}

This trick, while being very simple, can boost performance of a simple
element-operation by 10-20 percents, especially if the image is rather small
and the operation is quite simple.

Also, note that we use another OpenCV idiom in this function - we call
Mat::create() for the destination array instead of checking that it already has
the proper size and type. And while the newly allocated arrays are always
continuous, we still check the destination array, because create() does not
always allocate a new matrix.

===========================================================================
*cv-Mat::elemSize*

size_t Mat::elemSize() const¶
    Returns matrix element size in bytes

The method returns the matrix element size in bytes. For example, if the matrix
type is CV_16SC3 , the method will return 3*sizeof(short) or 6.

===========================================================================
*cv-Mat::elemSize1*

size_t Mat::elemSize1() const¶
    Returns size of each matrix element channel in bytes

The method returns the matrix element channel size in bytes, that is, it
ignores the number of channels. For example, if the matrix type is CV_16SC3 ,
the method will return sizeof(short) or 2.

===========================================================================
*cv-Mat::type*

int Mat::type() const¶
    Returns matrix element type

The method returns the matrix element type, an id, compatible with the CvMat
type system, like CV_16SC3 or 16-bit signed 3-channel array etc.

===========================================================================
*cv-Mat::depth*

int Mat::depth() const¶
    Returns matrix element depth

The method returns the matrix element depth id, i.e. the type of each
individual channel. For example, for 16-bit signed 3-channel array the method
will return CV_16S . The complete list of matrix types:

  • CV_8U - 8-bit unsigned integers ( 0..255 )
  • CV_8S - 8-bit signed integers ( -128..127 )
  • CV_16U - 16-bit unsigned integers ( 0..65535 )
  • CV_16S - 16-bit signed integers ( -32768..32767 )
  • CV_32S - 32-bit signed integers ( -2147483648..2147483647 )
  • CV_32F - 32-bit floating-point numbers ( -FLT_MAX..FLT_MAX, INF, NAN )
  • CV_64F - 64-bit floating-point numbers ( -DBL_MAX..DBL_MAX, INF, NAN )

===========================================================================
*cv-Mat::channels*

int Mat::channels() const¶
    Returns matrix element depth

The method returns the number of matrix channels.

===========================================================================
*cv-Mat::step1*

size_t Mat::step1() const¶
    Returns normalized step

The method returns the matrix step, divided by Mat::elemSize1() . It can be
useful for fast access to arbitrary matrix element.

===========================================================================
*cv-Mat::size*

Size Mat::size() const¶
    Returns the matrix size

The method returns the matrix size: Size(cols, rows) .

===========================================================================
*cv-Mat::empty*

bool Mat::empty() const¶
    Returns true if the array has no elemens

The method returns true if Mat::total() is 0 or if Mat::data is NULL. Because
of pop_back() and resize() methods M.total() == 0 does not imply that M.data ==
NULL .

===========================================================================
*cv-Mat::ptr*

uchar* Mat::ptr(int i=0)~

const uchar* Mat::ptr(int i=0) const

template<typename _Tp> _Tp* Mat::ptr(int i=0)

template<typename _Tp> const _Tp* Mat::ptr(int i=0) const

    Return pointer to the specified matrix row

    Parameter: i – The 0-based row index

The methods return uchar* or typed pointer to the specified matrix row. See the
sample in Mat::isContinuous() () on how to use these methods.

===========================================================================
*cv-Mat::at*

template<typename T> T& Mat::at(int i) const~

template<typename T> const T& Mat::at(int i) const

template<typename T> T& Mat::at(int i, int j)

template<typename T> const T& Mat::at(int i, int j) const

template<typename T> T& Mat::at(Point pt)

template<typename T> const T& Mat::at(Point pt) const

template<typename T> T& Mat::at(int i, int j, int k)

template<typename T> const T& Mat::at(int i, int j, int k) const

template<typename T> T& Mat::at(const int* idx)

template<typename T> const T& Mat::at(const int* idx) const

    Return reference to the specified array element

                  • i, j, k – Indices along the dimensions 0, 1 and 2,
    Parameters:     respectively
                  • pt – The element position specified as Point(j,i)
                  • idx – The array of Mat::dims indices

The template methods return reference to the specified array element. For the
sake of higher performance the index range checks are only performed in Debug
configuration.

Note that the variants with a single index (i) can be used to access elements
of single-row or single-column 2-dimensional arrays. That is, if, for example,
A is 1 x N floating-point matrix and B is M x 1 integer matrix, you can simply
write A.at<float>(k+4) and B.at<int>(2*i+1) instead of A.at<float>(0,k+4) and
B.at<int>(2*i+1,0) , respectively.

Here is an example of initialization of a Hilbert matrix:

Mat H(100, 100, CV_64F);
for(int i = 0; i < H.rows; i++)
    for(int j = 0; j < H.cols; j++)
        H.at<double>(i,j)=1./(i+j+1);

===========================================================================
*cv-Mat::begin*

template<typename _Tp> MatIterator_<_Tp> Mat::begin() template<typename _Tp>
    MatConstIterator_<_Tp> Mat::begin() const¶
    Return the matrix iterator, set to the first matrix element

The methods return the matrix read-only or read-write iterators. The use of
matrix iterators is very similar to the use of bi-directional STL iterators.
Here is the alpha blending function rewritten using the matrix iterators:

template<typename T>
void alphaBlendRGBA(const Mat& src1, const Mat& src2, Mat& dst)
{
    typedef Vec<T, 4> VT;

    const float alpha_scale = (float)std::numeric_limits<T>::max(),
                inv_scale = 1.f/alpha_scale;

    CV_Assert( src1.type() == src2.type() &&
               src1.type() == DataType<VT>::type &&
               src1.size() == src2.size());
    Size size = src1.size();
    dst.create(size, src1.type());

    MatConstIterator_<VT> it1 = src1.begin<VT>(), it1_end = src1.end<VT>();
    MatConstIterator_<VT> it2 = src2.begin<VT>();
    MatIterator_<VT> dst_it = dst.begin<VT>();

    for( ; it1 != it1_end; ++it1, ++it2, ++dst_it )
    {
        VT pix1 = *it1, pix2 = *it2;
        float alpha = pix1[3]*inv_scale, beta = pix2[3]*inv_scale;
        *dst_it = VT(saturate_cast<T>(pix1[0]*alpha + pix2[0]*beta),
                     saturate_cast<T>(pix1[1]*alpha + pix2[1]*beta),
                     saturate_cast<T>(pix1[2]*alpha + pix2[2]*beta),
                     saturate_cast<T>((1 - (1-alpha)*(1-beta))*alpha_scale));
    }
}

===========================================================================
*cv-Mat::end*

template<typename _Tp> MatIterator_<_Tp> Mat::end() template<typename _Tp>
    MatConstIterator_<_Tp> Mat::end() const¶
    Return the matrix iterator, set to the after-last matrix element

The methods return the matrix read-only or read-write iterators, set to the
point following the last matrix element.

===========================================================================
*cv-Mat_*

Template matrix class derived from Mat

template<typename _Tp> class Mat_ : public Mat
{
public:
    // ... some specific methods
    //         and
    // no new extra fields
};

The class Mat_<_Tp> is a “thin” template wrapper on top of Mat class. It does
not have any extra data fields, nor it or Mat have any virtual methods and thus
references or pointers to these two classes can be freely converted one to
another. But do it with care, e.g.:

// create 100x100 8-bit matrix
Mat M(100,100,CV_8U);
// this will compile fine. no any data conversion will be done.
Mat_<float>& M1 = (Mat_<float>&)M;
// the program will likely crash at the statement below
M1(99,99) = 1.f;

While Mat is sufficient in most cases, Mat_ can be more convenient if you use a
lot of element access operations and if you know matrix type at compile time.
Note that Mat::at<_Tp>(int y, int x) and Mat_<_Tp>::operator ()(int y, int x)
do absolutely the same and run at the same speed, but the latter is certainly
shorter:

Mat_<double> M(20,20);
for(int i = 0; i < M.rows; i++)
    for(int j = 0; j < M.cols; j++)
        M(i,j) = 1./(i+j+1);
Mat E, V;
eigen(M,E,V);
cout << E.at<double>(0,0)/E.at<double>(M.rows-1,0);

How to use ``Mat_`` for multi-channel images/matrices? This is simple - just
pass Vec as Mat_ parameter:

// allocate 320x240 color image and fill it with green (in RGB space)
Mat_<Vec3b> img(240, 320, Vec3b(0,255,0));
// now draw a diagonal white line
for(int i = 0; i < 100; i++)
    img(i,i)=Vec3b(255,255,255);
// and now scramble the 2nd (red) channel of each pixel
for(int i = 0; i < img.rows; i++)
    for(int j = 0; j < img.cols; j++)
        img(i,j)[2] ^= (uchar)(i ^ j);

===========================================================================
*cv-NAryMatIterator*

n-ary multi-dimensional array iterator

class CV_EXPORTS NAryMatIterator
{
public:
    //! the default constructor
    NAryMatIterator();
    //! the full constructor taking arbitrary number of n-dim matrices
    NAryMatIterator(const Mat** arrays, Mat* planes, int narrays=-1);
    //! the separate iterator initialization method
    void init(const Mat** arrays, Mat* planes, int narrays=-1);

    //! proceeds to the next plane of every iterated matrix
    NAryMatIterator& operator ++();
    //! proceeds to the next plane of every iterated matrix (postfix increment operator)
    NAryMatIterator operator ++(int);

    ...
    int nplanes; // the total number of planes
};

The class is used for implementation of unary, binary and, generally, n-ary
element-wise operations on multi-dimensional arrays. Some of the arguments of
n-ary function may be continuous arrays, some may be not. It is possible to use
conventional MatIterator ‘s for each array, but it can be a big overhead to
increment all of the iterators after each small operations. That’s where
NAryMatIterator can be used. Using it, you can iterate though several matrices
simultaneously as long as they have the same geometry (dimensionality and all
the dimension sizes are the same). On each iteration it.planes[0] , it.planes
[1] , ... will be the slices of the corresponding matrices.

Here is an example of how you can compute a normalized and thresholded 3D color
histogram:

void computeNormalizedColorHist(const Mat& image, Mat& hist, int N, double minProb)
{
    const int histSize[] = {N, N, N};

    // make sure that the histogram has proper size and type
    hist.create(3, histSize, CV_32F);

    // and clear it
    hist = Scalar(0);

    // the loop below assumes that the image
    // is 8-bit 3-channel, so let's check it.
    CV_Assert(image.type() == CV_8UC3);
    MatConstIterator_<Vec3b> it = image.begin<Vec3b>(),
                             it_end = image.end<Vec3b>();
    for( ; it != it_end; ++it )
    {
        const Vec3b& pix = *it;
        hist.at<float>(pix[0]*N/256, pix[1]*N/256, pix[2]*N/256) += 1.f;
    }

    minProb *= image.rows*image.cols;
    Mat plane;
    NAryMatIterator it(&hist, &plane, 1);
    double s = 0;
    // iterate through the matrix. on each iteration
    // it.planes[*] (of type Mat) will be set to the current plane.
    for(int p = 0; p < it.nplanes; p++, ++it)
    {
        threshold(it.planes[0], it.planes[0], minProb, 0, THRESH_TOZERO);
        s += sum(it.planes[0])[0];
    }

    s = 1./s;
    it = NAryMatIterator(&hist, &plane, 1);
    for(int p = 0; p < it.nplanes; p++, ++it)
        it.planes[0] *= s;
}

===========================================================================
*cv-SparseMat*

Sparse n-dimensional array.

class SparseMat
{
public:
    typedef SparseMatIterator iterator;
    typedef SparseMatConstIterator const_iterator;

    // internal structure - sparse matrix header
    struct Hdr
    {
        ...
    };

    // sparse matrix node - element of a hash table
    struct Node
    {
        size_t hashval;
        size_t next;
        int idx[CV_MAX_DIM];
    };

    ////////// constructors and destructor //////////
    // default constructor
    SparseMat();
    // creates matrix of the specified size and type
    SparseMat(int dims, const int* _sizes, int _type);
    // copy constructor
    SparseMat(const SparseMat& m);
    // converts dense array to the sparse form,
    // if try1d is true and matrix is a single-column matrix (Nx1),
    // then the sparse matrix will be 1-dimensional.
    SparseMat(const Mat& m, bool try1d=false);
    // converts old-style sparse matrix to the new-style.
    // all the data is copied, so that "m" can be safely
    // deleted after the conversion
    SparseMat(const CvSparseMat* m);
    // destructor
    ~SparseMat();

    ///////// assignment operations ///////////

    // this is O(1) operation; no data is copied
    SparseMat& operator = (const SparseMat& m);
    // (equivalent to the corresponding constructor with try1d=false)
    SparseMat& operator = (const Mat& m);

    // creates full copy of the matrix
    SparseMat clone() const;

    // copy all the data to the destination matrix.
    // the destination will be reallocated if needed.
    void copyTo( SparseMat& m ) const;
    // converts 1D or 2D sparse matrix to dense 2D matrix.
    // If the sparse matrix is 1D, then the result will
    // be a single-column matrix.
    void copyTo( Mat& m ) const;
    // converts arbitrary sparse matrix to dense matrix.
    // multiplies all the matrix elements by the specified scalar
    void convertTo( SparseMat& m, int rtype, double alpha=1 ) const;
    // converts sparse matrix to dense matrix with optional type conversion and scaling.
    // When rtype=-1, the destination element type will be the same
    // as the sparse matrix element type.
    // Otherwise rtype will specify the depth and
    // the number of channels will remain the same is in the sparse matrix
    void convertTo( Mat& m, int rtype, double alpha=1, double beta=0 ) const;

    // not used now
    void assignTo( SparseMat& m, int type=-1 ) const;

    // reallocates sparse matrix. If it was already of the proper size and type,
    // it is simply cleared with clear(), otherwise,
    // the old matrix is released (using release()) and the new one is allocated.
    void create(int dims, const int* _sizes, int _type);
    // sets all the matrix elements to 0, which means clearing the hash table.
    void clear();
    // manually increases reference counter to the header.
    void addref();
    // decreses the header reference counter, when it reaches 0,
    // the header and all the underlying data are deallocated.
    void release();

    // converts sparse matrix to the old-style representation.
    // all the elements are copied.
    operator CvSparseMat*() const;
    // size of each element in bytes
    // (the matrix nodes will be bigger because of
    //  element indices and other SparseMat::Node elements).
    size_t elemSize() const;
    // elemSize()/channels()
    size_t elemSize1() const;

    // the same is in Mat
    int type() const;
    int depth() const;
    int channels() const;

    // returns the array of sizes and 0 if the matrix is not allocated
    const int* size() const;
    // returns i-th size (or 0)
    int size(int i) const;
    // returns the matrix dimensionality
    int dims() const;
    // returns the number of non-zero elements
    size_t nzcount() const;

    // compute element hash value from the element indices:
    // 1D case
    size_t hash(int i0) const;
    // 2D case
    size_t hash(int i0, int i1) const;
    // 3D case
    size_t hash(int i0, int i1, int i2) const;
    // n-D case
    size_t hash(const int* idx) const;

    // low-level element-acccess functions,
    // special variants for 1D, 2D, 3D cases and the generic one for n-D case.
    //
    // return pointer to the matrix element.
    //  if the element is there (it's non-zero), the pointer to it is returned
    //  if it's not there and createMissing=false, NULL pointer is returned
    //  if it's not there and createMissing=true, then the new element
    //    is created and initialized with 0. Pointer to it is returned
    //  If the optional hashval pointer is not NULL, the element hash value is
    //  not computed, but *hashval is taken instead.
    uchar* ptr(int i0, bool createMissing, size_t* hashval=0);
    uchar* ptr(int i0, int i1, bool createMissing, size_t* hashval=0);
    uchar* ptr(int i0, int i1, int i2, bool createMissing, size_t* hashval=0);
    uchar* ptr(const int* idx, bool createMissing, size_t* hashval=0);

    // higher-level element access functions:
    // ref<_Tp>(i0,...[,hashval]) - equivalent to *(_Tp*)ptr(i0,...true[,hashval]).
    //    always return valid reference to the element.
    //    If it's did not exist, it is created.
    // find<_Tp>(i0,...[,hashval]) - equivalent to (_const Tp*)ptr(i0,...false[,hashval]).
    //    return pointer to the element or NULL pointer if the element is not there.
    // value<_Tp>(i0,...[,hashval]) - equivalent to
    //    { const _Tp* p = find<_Tp>(i0,...[,hashval]); return p ? *p : _Tp(); }
    //    that is, 0 is returned when the element is not there.
    // note that _Tp must match the actual matrix type -
    // the functions do not do any on-fly type conversion

    // 1D case
    template<typename _Tp> _Tp& ref(int i0, size_t* hashval=0);
    template<typename _Tp> _Tp value(int i0, size_t* hashval=0) const;
    template<typename _Tp> const _Tp* find(int i0, size_t* hashval=0) const;

    // 2D case
    template<typename _Tp> _Tp& ref(int i0, int i1, size_t* hashval=0);
    template<typename _Tp> _Tp value(int i0, int i1, size_t* hashval=0) const;
    template<typename _Tp> const _Tp* find(int i0, int i1, size_t* hashval=0) const;

    // 3D case
    template<typename _Tp> _Tp& ref(int i0, int i1, int i2, size_t* hashval=0);
    template<typename _Tp> _Tp value(int i0, int i1, int i2, size_t* hashval=0) const;
    template<typename _Tp> const _Tp* find(int i0, int i1, int i2, size_t* hashval=0) const;

    // n-D case
    template<typename _Tp> _Tp& ref(const int* idx, size_t* hashval=0);
    template<typename _Tp> _Tp value(const int* idx, size_t* hashval=0) const;
    template<typename _Tp> const _Tp* find(const int* idx, size_t* hashval=0) const;

    // erase the specified matrix element.
    // When there is no such element, the methods do nothing
    void erase(int i0, int i1, size_t* hashval=0);
    void erase(int i0, int i1, int i2, size_t* hashval=0);
    void erase(const int* idx, size_t* hashval=0);

    // return the matrix iterators,
    //   pointing to the first sparse matrix element,
    SparseMatIterator begin();
    SparseMatConstIterator begin() const;
    //   ... or to the point after the last sparse matrix element
    SparseMatIterator end();
    SparseMatConstIterator end() const;

    // and the template forms of the above methods.
    // _Tp must match the actual matrix type.
    template<typename _Tp> SparseMatIterator_<_Tp> begin();
    template<typename _Tp> SparseMatConstIterator_<_Tp> begin() const;
    template<typename _Tp> SparseMatIterator_<_Tp> end();
    template<typename _Tp> SparseMatConstIterator_<_Tp> end() const;

    // return value stored in the sparse martix node
    template<typename _Tp> _Tp& value(Node* n);
    template<typename _Tp> const _Tp& value(const Node* n) const;

    ////////////// some internal-use methods ///////////////
    ...

    // pointer to the sparse matrix header
    Hdr* hdr;
};

The class SparseMat represents multi-dimensional sparse numerical arrays. Such
a sparse array can store elements of any type that Mat can store. “Sparse”
means that only non-zero elements are stored (though, as a result of operations
on a sparse matrix, some of its stored elements can actually become 0. It’s up
to the user to detect such elements and delete them using SparseMat::erase ).
The non-zero elements are stored in a hash table that grows when it’s filled
enough, so that the search time is O(1) in average (regardless of whether
element is there or not). Elements can be accessed using the following methods:

 1. query operations ( SparseMat::ptr and the higher-level SparseMat::ref ,
    SparseMat::value and SparseMat::find ), e.g.:

    const int dims = 5;
    int size[] = {10, 10, 10, 10, 10};
    SparseMat sparse_mat(dims, size, CV_32F);
    for(int i = 0; i < 1000; i++)
    {
        int idx[dims];
        for(int k = 0; k < dims; k++)
            idx[k] = rand()
        sparse_mat.ref<float>(idx) += 1.f;
    }

 2. sparse matrix iterators. Like Mat iterators and unlike MatND iterators, the
    sparse matrix iterators are STL-style, that is, the iteration loop is
    familiar to C++ users:

    // prints elements of a sparse floating-point matrix
    // and the sum of elements.
    SparseMatConstIterator_<float>
        it = sparse_mat.begin<float>(),
        it_end = sparse_mat.end<float>();
    double s = 0;
    int dims = sparse_mat.dims();
    for(; it != it_end; ++it)
    {
        // print element indices and the element value
        const Node* n = it.node();
        printf("(")
        for(int i = 0; i < dims; i++)
            printf("
        printf(":
        s += *it;
    }
    printf("Element sum is

    If you run this loop, you will notice that elements are enumerated in no
    any logical order (lexicographical etc.), they come in the same order as
    they stored in the hash table, i.e. semi-randomly. You may collect pointers
    to the nodes and sort them to get the proper ordering. Note, however, that
    pointers to the nodes may become invalid when you add more elements to the
    matrix; this is because of possible buffer reallocation.

 3. a combination of the above 2 methods when you need to process 2 or more
    sparse matrices simultaneously, e.g. this is how you can compute
    unnormalized cross-correlation of the 2 floating-point sparse matrices:

    double cross_corr(const SparseMat& a, const SparseMat& b)
    {
        const SparseMat *_a = &a, *_b = &b;
        // if b contains less elements than a,
        // it's faster to iterate through b
        if(_a->nzcount() > _b->nzcount())
            std::swap(_a, _b);
        SparseMatConstIterator_<float> it = _a->begin<float>(),
                                       it_end = _a->end<float>();
        double ccorr = 0;
        for(; it != it_end; ++it)
        {
            // take the next element from the first matrix
            float avalue = *it;
            const Node* anode = it.node();
            // and try to find element with the same index in the second matrix.
            // since the hash value depends only on the element index,
            // we reuse hashvalue stored in the node
            float bvalue = _b->value<float>(anode->idx,&anode->hashval);
            ccorr += avalue*bvalue;
        }
        return ccorr;
    }

===========================================================================
*cv-SparseMat_*

Template sparse n-dimensional array class derived from SparseMat

template<typename _Tp> class SparseMat_ : public SparseMat
{
public:
    typedef SparseMatIterator_<_Tp> iterator;
    typedef SparseMatConstIterator_<_Tp> const_iterator;

    // constructors;
    // the created matrix will have data type = DataType<_Tp>::type
    SparseMat_();
    SparseMat_(int dims, const int* _sizes);
    SparseMat_(const SparseMat& m);
    SparseMat_(const SparseMat_& m);
    SparseMat_(const Mat& m);
    SparseMat_(const CvSparseMat* m);
    // assignment operators; data type conversion is done when necessary
    SparseMat_& operator = (const SparseMat& m);
    SparseMat_& operator = (const SparseMat_& m);
    SparseMat_& operator = (const Mat& m);
    SparseMat_& operator = (const MatND& m);

    // equivalent to the correspoding parent class methods
    SparseMat_ clone() const;
    void create(int dims, const int* _sizes);
    operator CvSparseMat*() const;

    // overriden methods that do extra checks for the data type
    int type() const;
    int depth() const;
    int channels() const;

    // more convenient element access operations.
    // ref() is retained (but <_Tp> specification is not need anymore);
    // operator () is equivalent to SparseMat::value<_Tp>
    _Tp& ref(int i0, size_t* hashval=0);
    _Tp operator()(int i0, size_t* hashval=0) const;
    _Tp& ref(int i0, int i1, size_t* hashval=0);
    _Tp operator()(int i0, int i1, size_t* hashval=0) const;
    _Tp& ref(int i0, int i1, int i2, size_t* hashval=0);
    _Tp operator()(int i0, int i1, int i2, size_t* hashval=0) const;
    _Tp& ref(const int* idx, size_t* hashval=0);
    _Tp operator()(const int* idx, size_t* hashval=0) const;

    // iterators
    SparseMatIterator_<_Tp> begin();
    SparseMatConstIterator_<_Tp> begin() const;
    SparseMatIterator_<_Tp> end();
    SparseMatConstIterator_<_Tp> end() const;
};

SparseMat_ is a thin wrapper on top of SparseMat , made in the same way as Mat_
. It simplifies notation of some operations, and that’s it.

int sz[] = {10, 20, 30};
SparseMat_<double> M(3, sz);
...
M.ref(1, 2, 3) = M(4, 5, 6) + M(7, 8, 9);

Help and Feedback

You did not find what you were looking for?

  • Try the Cheatsheet.
  • Ask a question in the user group/mailing list.
  • If you think something is missing or wrong in the documentation, please
    file a bug report.

Logo

Table Of Contents

  • Basic Structures
      □ DataType
      □ Point_
      □ Point3_
      □ Size_
      □ Rect_
      □ RotatedRect
      □ TermCriteria
      □ Matx
      □ Vec
      □ Scalar_
      □ Range
      □ Ptr
      □ Mat
      □ Matrix Expressions
      □ cv::Mat::Mat
      □ cv::Mat::Mat
      □ cv::Mat::operator =
      □ cv::Mat::operator MatExpr
      □ cv::Mat::row
      □ cv::Mat::col
      □ cv::Mat::rowRange
      □ cv::Mat::colRange
      □ cv::Mat::diag
      □ cv::Mat::clone
      □ cv::Mat::copyTo
      □ cv::Mat::convertTo
      □ cv::Mat::assignTo
      □ cv::Mat::setTo
      □ cv::reshape
      □ cv::Mat::t()
      □ cv::Mat::inv
      □ cv::Mat::mul
      □ cv::Mat::cross
      □ cv::Mat::dot
      □ cv::Mat::zeros
      □ cv::Mat::ones
      □ cv::Mat::eye
      □ cv::Mat::create
      □ cv::Mat::addref
      □ cv::Mat::release
      □ cv::Mat::resize
      □ Mat::push_back
      □ Mat::pop_back
      □ cv::Mat::locateROI
      □ cv::Mat::adjustROI
      □ cv::Mat::operator()
      □ cv::Mat::operator CvMat
      □ cv::Mat::operator IplImage
      □ cv::Mat::total
      □ cv::Mat::isContinuous
      □ cv::Mat::elemSize
      □ cv::Mat::elemSize1
      □ cv::Mat::type
      □ cv::Mat::depth
      □ cv::Mat::channels
      □ cv::Mat::step1
      □ cv::Mat::size
      □ cv::Mat::empty
      □ cv::Mat::ptr
      □ cv::Mat::at
      □ cv::Mat::begin
      □ cv::Mat::end
      □ Mat_
      □ NAryMatIterator
      □ SparseMat
      □ SparseMat_

Previous topic

core. The Core Functionality

Next topic

Operations on Arrays

This Page

  • Show Source

Quick search

[                  ] [Go] 
Enter search terms or a module, class or function name.

Navigation

  • index
  • next |
  • previous |
  • opencv v2.1 documentation »
  • core. The Core Functionality »

© Copyright 2010, authors. Created using Sphinx 0.6.2.
Navigation

  • index
  • next |
  • previous |
  • opencv v2.1 documentation »
  • core. The Core Functionality »

Operations on Arrays~

===========================================================================
*cv-abs*

MatExpr<...> abs(const Mat& src)~

MatExpr<...> abs(const MatExpr<...>& src)

    Computes absolute value of each matrix element

    Parameter: src – matrix or matrix expression

abs is a meta-function that is expanded to one of absdiff() forms:

  • C = abs(A-B) is equivalent to absdiff(A, B, C) and
  • C = abs(A) is equivalent to absdiff(A, Scalar::all(0), C) .
  • C = Mat_<Vec<uchar,n> >(abs(A*alpha + beta)) is equivalent to
    convertScaleAbs(A, C, alpha, beta)

The output matrix will have the same size and the same type as the input one
(except for the last case, where C will be depth=CV_8U ).

See also: Matrix Expressions , absdiff() ,

===========================================================================
*cv-absdiff*

void absdiff(const Mat& src1, const Mat& src2, Mat& dst)~

void absdiff(const Mat& src1, const Scalar& sc, Mat& dst)

void absdiff(const MatND& src1, const MatND& src2, MatND& dst)

void absdiff(const MatND& src1, const Scalar& sc, MatND& dst)

    Computes per-element absolute difference between 2 arrays or between array
    and a scalar.

                  • src1 – The first input array
                  • src2 – The second input array; Must be the same size and
    Parameters:     same type as src1
                  • sc – Scalar; the second input parameter
                  • dst – The destination array; it will have the same size and
                    same type as src1 ; see Mat::create

The functions absdiff compute:

  • absolute difference between two arrays

    dst (I) = saturate (| src1 (I) - src2
    (I)|)

  • or absolute difference between array and a scalar:

    dst (I) = saturate (| src1 (I) - sc |)

where I is multi-dimensional index of array elements. in the case of
multi-channel arrays each channel is processed independently.

See also: abs() ,

===========================================================================
*cv-add*

void add(const Mat& src1, const Mat& src2, Mat& dst)~

void add(const Mat& src1, const Mat& src2, Mat& dst, const Mat& mask)

void add(const Mat& src1, const Scalar& sc, Mat& dst, const Mat& mask=Mat())

void add(const MatND& src1, const MatND& src2, MatND& dst)

void add(const MatND& src1, const MatND& src2, MatND& dst, const MatND& mask)

void add(const MatND& src1, const Scalar& sc, MatND& dst, const MatND& mask=
    MatND())

    Computes the per-element sum of two arrays or an array and a scalar.

                  • src1 – The first source array
                  • src2 – The second source array. It must have the same size
                    and same type as src1
                  • sc – Scalar; the second input parameter
    Parameters:   • dst – The destination array; it will have the same size and
                    same type as src1 ; see Mat::create
                  • mask – The optional operation mask, 8-bit single channel
                    array; specifies elements of the destination array to be
                    changed

The functions add compute:

  • the sum of two arrays:

    dst (I) = saturate ( src1 (I) + src2
    (I)) \quad if mask (I) \ne0

  • or the sum of array and a scalar:

    dst (I) = saturate ( src1 (I) + sc ) \
    quad if mask (I) \ne0

where I is multi-dimensional index of array elements.

The first function in the above list can be replaced with matrix expressions:

dst = src1 + src2;
dst += src1; // equivalent to add(dst, src1, dst);

in the case of multi-channel arrays each channel is processed independently.

See also: subtract() , addWeighted() , scaleAdd() , convertScale() , Matrix
Expressions , .

===========================================================================
*cv-addWeighted*

void addWeighted(const Mat& src1, double alpha, const Mat& src2, double beta,
    double gamma, Mat& dst)~

void addWeighted(const MatND& src1, double alpha, const MatND& src2, double
    beta, double gamma, MatND& dst)

    Computes the weighted sum of two arrays.

                  • src1 – The first source array
                  • alpha – Weight for the first array elements
                  • src2 – The second source array; must have the same size and
    Parameters:     same type as src1
                  • beta – Weight for the second array elements
                  • dst – The destination array; it will have the same size and
                    same type as src1
                  • gamma – Scalar, added to each sum

The functions addWeighted calculate the weighted sum of two arrays as follows:

dst (I)= saturate ( src1 (I)* alpha + \
texttt{src2} (I)* beta + gamma )

where I is multi-dimensional index of array elements.

The first function can be replaced with a matrix expression:

dst = src1*alpha + src2*beta + gamma;

In the case of multi-channel arrays each channel is processed independently.

See also: add() , subtract() , scaleAdd() , convertScale() , Matrix Expressions
, .

===========================================================================
*cv-bitwise_and*

void bitwise_and(const Mat& src1, const Mat& src2, Mat& dst, const Mat& mask=
    Mat())~

void bitwise_and(const Mat& src1, const Scalar& sc, Mat& dst, const Mat& mask=
    Mat())

void bitwise_and(const MatND& src1, const MatND& src2, MatND& dst, const MatND&
    mask=MatND())

void bitwise_and(const MatND& src1, const Scalar& sc, MatND& dst, const MatND&
    mask=MatND())

    Calculates per-element bit-wise conjunction of two arrays and an array and
    a scalar.

                  • src1 – The first source array
                  • src2 – The second source array. It must have the same size
                    and same type as src1
                  • sc – Scalar; the second input parameter
    Parameters:   • dst – The destination array; it will have the same size and
                    same type as src1 ; see Mat::create
                  • mask – The optional operation mask, 8-bit single channel
                    array; specifies elements of the destination array to be
                    changed

The functions bitwise_and compute per-element bit-wise logical conjunction:

  • of two arrays

    dst (I) = src1 (I) \wedge src2 (I) \quad \texttt
    {if mask} (I) \ne0

  • or array and a scalar:

    dst (I) = src1 (I) \wedge sc \quad \texttt{if
    mask} (I) \ne0

In the case of floating-point arrays their machine-specific bit representations
(usually IEEE754-compliant) are used for the operation, and in the case of
multi-channel arrays each channel is processed independently.

See also: , ,

===========================================================================
*cv-bitwise_not*

void bitwise_not(const Mat& src, Mat& dst)~

void bitwise_not(const MatND& src, MatND& dst)

    Inverts every bit of array

                  • src1 – The source array
                  • dst – The destination array; it is reallocated to be of the
    Parameters:     same size and the same type as src ; see Mat::create
                  • mask – The optional operation mask, 8-bit single channel
                    array; specifies elements of the destination array to be
                    changed

The functions bitwise_not compute per-element bit-wise inversion of the source
array:

dst (I) = \neg src (I)

In the case of floating-point source array its machine-specific bit
representation (usually IEEE754-compliant) is used for the operation. in the
case of multi-channel arrays each channel is processed independently.

See also: , ,

===========================================================================
*cv-bitwise_or*

void bitwise_or(const Mat& src1, const Mat& src2, Mat& dst, const Mat& mask=Mat
    ())~

void bitwise_or(const Mat& src1, const Scalar& sc, Mat& dst, const Mat& mask=
    Mat())

void bitwise_or(const MatND& src1, const MatND& src2, MatND& dst, const MatND&
    mask=MatND())

void bitwise_or(const MatND& src1, const Scalar& sc, MatND& dst, const MatND&
    mask=MatND())

    Calculates per-element bit-wise disjunction of two arrays and an array and
    a scalar.

                  • src1 – The first source array
                  • src2 – The second source array. It must have the same size
                    and same type as src1
                  • sc – Scalar; the second input parameter
    Parameters:   • dst – The destination array; it is reallocated to be of the
                    same size and the same type as src1 ; see Mat::create
                  • mask – The optional operation mask, 8-bit single channel
                    array; specifies elements of the destination array to be
                    changed

The functions bitwise_or compute per-element bit-wise logical disjunction

  • of two arrays

    dst (I) = src1 (I) \vee src2 (I) \quad \texttt
    {if mask} (I) \ne0

  • or array and a scalar:

    dst (I) = src1 (I) \vee sc \quad \texttt{if
    mask} (I) \ne0

In the case of floating-point arrays their machine-specific bit representations
(usually IEEE754-compliant) are used for the operation. in the case of
multi-channel arrays each channel is processed independently.

See also: , ,

===========================================================================
*cv-bitwise_xor*

void bitwise_xor(const Mat& src1, const Mat& src2, Mat& dst, const Mat& mask=
    Mat())~

void bitwise_xor(const Mat& src1, const Scalar& sc, Mat& dst, const Mat& mask=
    Mat())

void bitwise_xor(const MatND& src1, const MatND& src2, MatND& dst, const MatND&
    mask=MatND())

void bitwise_xor(const MatND& src1, const Scalar& sc, MatND& dst, const MatND&
    mask=MatND())

    Calculates per-element bit-wise “exclusive or” operation on two arrays and
    an array and a scalar.

                  • src1 – The first source array
                  • src2 – The second source array. It must have the same size
                    and same type as src1
                  • sc – Scalar; the second input parameter
    Parameters:   • dst – The destination array; it is reallocated to be of the
                    same size and the same type as src1 ; see Mat::create
                  • mask – The optional operation mask, 8-bit single channel
                    array; specifies elements of the destination array to be
                    changed

The functions bitwise_xor compute per-element bit-wise logical “exclusive or”
operation

  • on two arrays

    dst (I) = src1 (I) \oplus src2 (I) \quad \texttt
    {if mask} (I) \ne0

  • or array and a scalar:

    dst (I) = src1 (I) \oplus sc \quad \texttt{if
    mask} (I) \ne0

In the case of floating-point arrays their machine-specific bit representations
(usually IEEE754-compliant) are used for the operation. in the case of
multi-channel arrays each channel is processed independently.

See also: , ,

===========================================================================
*cv-calcCovarMatrix*

void calcCovarMatrix(const Mat* samples, int nsamples, Mat& covar, Mat& mean,
    int flags, int ctype=CV_64F)~

void calcCovarMatrix(const Mat& samples, Mat& covar, Mat& mean, int flags, int
    ctype=CV_64F)

    Calculates covariation matrix of a set of vectors

                  • samples – The samples, stored as separate matrices, or as
                    rows or columns of a single matrix
                  • nsamples – The number of samples when they are stored
                    separately
                  • covar – The output covariance matrix; it will have type=
                    ctype and square size
                  • mean – The input or output (depending on the flags) array -
                    the mean (average) vector of the input vectors
                  • flags –

                    The operation flags, a combination of the following values

                      □ CV_COVAR_SCRAMBLED The output covariance matrix is
                        calculated as:


                            scale * [ vects [0]- \texttt
                            {mean} , vects [1]- mean ,...]^T
                            * [ vects [0]- mean , \texttt
                            {vects} [1]- mean ,...]

                            , that is, the covariance matrix will be \texttt
                            {nsamples} \times nsamples . Such an
                            unusual covariance matrix is used for fast PCA of a
                            set of very large vectors (see, for example, the
                            EigenFaces technique for face recognition).
                            Eigenvalues of this “scrambled” matrix will match
                            the eigenvalues of the true covariance matrix and
                            the “true” eigenvectors can be easily calculated
                            from the eigenvectors of the “scrambled” covariance
                            matrix.

                      □ CV_COVAR_NORMAL The output covariance matrix is
    Parameters:         calculated as:


                            scale * [ vects [0]- \texttt
                            {mean} , vects [1]- mean ,...] \
                            cdot [ vects [0]- mean , \texttt
                            {vects} [1]- mean ,...]^T

                            , that is, covar will be a square matrix of the
                            same size as the total number of elements in each
                            input vector. One and only one of
                            CV_COVAR_SCRAMBLED and CV_COVAR_NORMAL must be
                            specified

                      □ CV_COVAR_USE_AVG If the flag is specified, the function
                        does not calculate mean from the input vectors, but,
                        instead, uses the passed mean vector. This is useful if
                        mean has been pre-computed or known a-priori, or if the
                        covariance matrix is calculated by parts - in this
                        case, mean is not a mean vector of the input sub-set of
                        vectors, but rather the mean vector of the whole set.
                      □ CV_COVAR_SCALE If the flag is specified, the covariance
                        matrix is scaled. In the “normal” mode scale is 1./
                        nsamples ; in the “scrambled” mode scale is the
                        reciprocal of the total number of elements in each
                        input vector. By default (if the flag is not specified)
                        the covariance matrix is not scaled (i.e. scale=1 ).
                      □ CV_COVAR_ROWS [Only useful in the second variant of the
                        function] The flag means that all the input vectors are
                        stored as rows of the samples matrix. mean should be a
                        single-row vector in this case.
                      □ CV_COVAR_COLS [Only useful in the second variant of the
                        function] The flag means that all the input vectors are
                        stored as columns of the samples matrix. mean should be
                        a single-column vector in this case.

The functions calcCovarMatrix calculate the covariance matrix and, optionally,
the mean vector of the set of input vectors.

See also: PCA() , mulTransposed() , Mahalanobis()

===========================================================================
*cv-cartToPolar*

void cartToPolar(const Mat& x, const Mat& y, Mat& magnitude, Mat& angle, bool
    angleInDegrees=false)~

    Calculates the magnitude and angle of 2d vectors.

                  • x – The array of x-coordinates; must be single-precision or
                    double-precision floating-point array
                  • y – The array of y-coordinates; it must have the same size
                    and same type as x
                  • magnitude – The destination array of magnitudes of the same
    Parameters:     size and same type as x
                  • angle – The destination array of angles of the same size
                    and same type as x . The angles are measured in radians (0
                    to 2 \pi ) or in degrees (0 to 360 degrees).
                  • angleInDegrees – The flag indicating whether the angles are
                    measured in radians, which is default mode, or in degrees

The function cartToPolar calculates either the magnitude, angle, or both of
every 2d vector (x(I),y(I)):

\begin{array}{l} magnitude (I)= \sqrt{x(I)^2+y(I)^2}
, \\ angle (I)= atan2 ( y (I), x (I))[ \
cdot180 / \pi ] \end{array}

The angles are calculated with \sim\,0.3^\circ accuracy. For the (0,0) point,
the angle is set to 0.

===========================================================================
*cv-checkRange*

bool checkRange(const Mat& src, bool quiet=true, Point* pos=0, double minVal=
    -DBL_MAX, double maxVal=DBL_MAX)~

bool checkRange(const MatND& src, bool quiet=true, int* pos=0, double minVal=
    -DBL_MAX, double maxVal=DBL_MAX)

    Checks every element of an input array for invalid values.

                  • src – The array to check
                  • quiet – The flag indicating whether the functions quietly
                    return false when the array elements are out of range, or
                    they throw an exception.
    Parameters:   • pos – The optional output parameter, where the position of
                    the first outlier is stored. In the second function pos ,
                    when not NULL, must be a pointer to array of src.dims
                    elements
                  • minVal – The inclusive lower boundary of valid values range
                  • maxVal – The exclusive upper boundary of valid values range

The functions checkRange check that every array element is neither NaN nor \pm
\infty . When minVal < -DBL_MAX and maxVal < DBL_MAX , then the functions also
check that each value is between minVal and maxVal . in the case of
multi-channel arrays each channel is processed independently. If some values
are out of range, position of the first outlier is stored in pos (when \texttt
{pos}\ne0 ), and then the functions either return false (when quiet=true ) or
throw an exception.

===========================================================================
*cv-compare*

void compare(const Mat& src1, const Mat& src2, Mat& dst, int cmpop)~

void compare(const Mat& src1, double value, Mat& dst, int cmpop)

void compare(const MatND& src1, const MatND& src2, MatND& dst, int cmpop)

void compare(const MatND& src1, double value, MatND& dst, int cmpop)

    Performs per-element comparison of two arrays or an array and scalar value.

                  • src1 – The first source array
                  • src2 – The second source array; must have the same size and
                    same type as src1
                  • value – The scalar value to compare each array element with
                  • dst – The destination array; will have the same size as
                    src1 and type= CV_8UC1
                  • cmpop –

                    The flag specifying the relation between the elements to be
                    checked

    Parameters:       □ CMP_EQ src1(I) = src2(I) or \texttt
                        {src1}(I) = value
                      □ CMP_GT src1(I) > src2(I) or \texttt
                        {src1}(I) > value
                      □ CMP_GE src1(I) \geq src2(I) or \
                        texttt{src1}(I) \geq value
                      □ CMP_LT src1(I) < src2(I) or \texttt
                        {src1}(I) < value
                      □ CMP_LE src1(I) \leq src2(I) or \
                        texttt{src1}(I) \leq value
                      □ CMP_NE src1(I) \ne src2(I) or \texttt
                        {src1}(I) \ne value

The functions compare compare each element of src1 with the corresponding
element of src2 or with real scalar value . When the comparison result is true,
the corresponding element of destination array is set to 255, otherwise it is
set to 0:

  • dst(I) = src1(I) cmpop src2(I) ? 255 : 0
  • dst(I) = src1(I) cmpop value ? 255 : 0

The comparison operations can be replaced with the equivalent matrix
expressions:

Mat dst1 = src1 >= src2;
Mat dst2 = src1 < 8;
...

See also: checkRange() , min() , max() , threshold() , Matrix Expressions

===========================================================================
*cv-completeSymm*

void completeSymm(Mat& mtx, bool lowerToUpper=false)~

    Copies the lower or the upper half of a square matrix to another half.

                  • mtx – Input-output floating-point square matrix
    Parameters:   • lowerToUpper – If true, the lower half is copied to the
                    upper half, otherwise the upper half is copied to the lower
                    half

The function completeSymm copies the lower half of a square matrix to its
another half; the matrix diagonal remains unchanged:

  • mtx_{ij}=mtx_{ji} for i > j if lowerToUpper=false
  • mtx_{ij}=mtx_{ji} for i < j if lowerToUpper=true

See also: flip() , transpose()

===========================================================================
*cv-convertScaleAbs*

void convertScaleAbs(const Mat& src, Mat& dst, double alpha=1, double beta=0)~

    Scales, computes absolute values and converts the result to 8-bit.

                  • src – The source array
    Parameters:   • dst – The destination array
                  • alpha – The optional scale factor
                  • beta – The optional delta added to the scaled values

On each element of the input array the function convertScaleAbs performs 3
operations sequentially: scaling, taking absolute value, conversion to unsigned
8-bit type:

dst (I)= \texttt{saturate\_cast<uchar>} (| src (I)* \texttt
{alpha} + beta |)

in the case of multi-channel arrays the function processes each channel
independently. When the output is not 8-bit, the operation can be emulated by
calling Mat::convertTo method (or by using matrix expressions) and then by
computing absolute value of the result, for example:

Mat_<float> A(30,30);
randu(A, Scalar(-100), Scalar(100));
Mat_<float> B = A*5 + 3;
B = abs(B);
// Mat_<float> B = abs(A*5+3) will also do the job,
// but it will allocate a temporary matrix

See also: Mat::convertTo() , abs()

===========================================================================
*cv-countNonZero*

int countNonZero(const Mat& mtx)~

int countNonZero(const MatND& mtx)

    Counts non-zero array elements.

    Parameter: mtx – Single-channel array

The function cvCountNonZero returns the number of non-zero elements in mtx:

\sum _{I: \; mtx (I) \ne0 } 1

See also: mean() , meanStdDev() , norm() , minMaxLoc() , calcCovarMatrix()

===========================================================================
*cv-cubeRoot*

float cubeRoot(float val)~

    Computes cube root of the argument

    Parameter: val – The function argument

The function cubeRoot computes \sqrt[3]{val} . Negative arguments are
handled correctly, NaN and \pm\infty are not handled. The accuracy approaches
the maximum possible accuracy for single-precision data.

===========================================================================
*cv-cvarrToMat*

Mat cvarrToMat(const CvArr* src, bool copyData=false, bool allowND=true, int
    coiMode=0)~

    Converts CvMat, IplImage or CvMatND to cv::Mat.

                  • src – The source CvMat , IplImage or CvMatND
                  • copyData – When it is false (default value), no data is
                    copied, only the new header is created. In this case the
                    original array should not be deallocated while the new
                    matrix header is used. The the parameter is true, all the
                    data is copied, then user may deallocate the original array
                    right after the conversion
                  • allowND – When it is true (default value), then CvMatND is
                    converted to Mat if it’s possible (e.g. then the data is
                    contiguous). If it’s not possible, or when the parameter is
    Parameters:     false, the function will report an error
                  • coiMode –

                    The parameter specifies how the IplImage COI (when set) is
                    handled.

                      □ If coiMode=0 , the function will report an error if COI
                        is set.
                      □ If coiMode=1 , the function will never report an error;
                        instead it returns the header to the whole original
                        image and user will have to check and process COI
                        manually, see extractImageCOI() .

The function cvarrToMat converts CvMat , IplImage or CvMatND header to Mat()
header, and optionally duplicates the underlying data. The constructed header
is returned by the function.

When copyData=false , the conversion is done really fast (in O(1) time) and the
newly created matrix header will have refcount=0 , which means that no
reference counting is done for the matrix data, and user has to preserve the
data until the new header is destructed. Otherwise, when copyData=true , the
new buffer will be allocated and managed as if you created a new matrix from
scratch and copy the data there. That is, cvarrToMat(src, true) :math:`\sim`
cvarrToMat(src, false).clone() (assuming that COI is not set). The function
provides uniform way of supporting CvArr paradigm in the code that is migrated
to use new-style data structures internally. The reverse transformation, from
Mat() to CvMat or IplImage can be done by simple assignment:

CvMat* A = cvCreateMat(10, 10, CV_32F);
cvSetIdentity(A);
IplImage A1; cvGetImage(A, &A1);
Mat B = cvarrToMat(A);
Mat B1 = cvarrToMat(&A1);
IplImage C = B;
CvMat C1 = B1;
// now A, A1, B, B1, C and C1 are different headers
// for the same 10x10 floating-point array.
// note, that you will need to use "&"
// to pass C & C1 to OpenCV functions, e.g:
printf("

Normally, the function is used to convert an old-style 2D array ( CvMat or
IplImage ) to Mat , however, the function can also take CvMatND on input and
create Mat() for it, if it’s possible. And for CvMatND A it is possible if and
only if A.dim[i].size*A.dim.step[i] == A.dim.step[i-1] for all or for all but
one i, 0 < i < A.dims . That is, the matrix data should be continuous or it
should be representable as a sequence of continuous matrices. By using this
function in this way, you can process CvMatND using arbitrary element-wise
function. But for more complex operations, such as filtering functions, it will
not work, and you need to convert CvMatND to MatND() using the corresponding
constructor of the latter.

The last parameter, coiMode , specifies how to react on an image with COI set:
by default it’s 0, and then the function reports an error when an image with
COI comes in. And coiMode=1 means that no error is signaled - user has to check
COI presence and handle it manually. The modern structures, such as Mat() and
MatND() do not support COI natively. To process individual channel of an
new-style array, you will need either to organize loop over the array (e.g.
using matrix iterators) where the channel of interest will be processed, or
extract the COI using mixChannels() (for new-style arrays) or extractImageCOI()
(for old-style arrays), process this individual channel and insert it back to
the destination array if need (using mixChannel() or insertImageCOI() ,
respectively).

See also: cvGetImage() , cvGetMat() , cvGetMatND() , extractImageCOI() ,
insertImageCOI() , mixChannels()

===========================================================================
*cv-dct*

void dct(const Mat& src, Mat& dst, int flags=0)~

    Performs a forward or inverse discrete cosine transform of 1D or 2D array

                  • src – The source floating-point array
                  • dst – The destination array; will have the same size and
                    same type as src
                  • flags –

                    Transformation flags, a combination of the following values

    Parameters:       □ DCT_INVERSE do an inverse 1D or 2D transform instead of
                        the default forward transform.
                      □ DCT_ROWS do a forward or inverse transform of every
                        individual row of the input matrix. This flag allows
                        user to transform multiple vectors simultaneously and
                        can be used to decrease the overhead (which is
                        sometimes several times larger than the processing
                        itself), to do 3D and higher-dimensional transforms and
                        so forth.

The function dct performs a forward or inverse discrete cosine transform (DCT)
of a 1D or 2D floating-point array:

Forward Cosine transform of 1D vector of N elements:

Y = C^{(N)} * X

where

C^{(N)}_{jk}= \sqrt{\alpha_j/N} \cos \left ( \frac{\pi(2k+1)j}{2N} \right )

and \alpha_0=1 , \alpha_j=2 for j > 0 .

Inverse Cosine transform of 1D vector of N elements:

X = \left (C^{(N)} \right )^{-1} * Y = \left (C^{(N)} \right )^T * Y

(since C^{(N)} is orthogonal matrix, C^{(N)} * \left(C^{(N)}\right)^T = I )

Forward Cosine transform of 2D M \times N matrix:

Y = C^{(N)} * X * \left (C^{(N)} \right )^T

Inverse Cosine transform of 2D vector of M \times N elements:

X = \left (C^{(N)} \right )^T * X * C^{(N)}

The function chooses the mode of operation by looking at the flags and size of
the input array:

  • if (flags & DCT_INVERSE) == 0 , the function does forward 1D or 2D
    transform, otherwise it is inverse 1D or 2D transform.
  • if (flags & DCT_ROWS) :math:`\ne` 0 , the function performs 1D transform of
    each row.
  • otherwise, if the array is a single column or a single row, the function
    performs 1D transform
  • otherwise it performs 2D transform.

Important note : currently cv::dct supports even-size arrays (2, 4, 6 ...). For
data analysis and approximation you can pad the array when necessary.

Also, the function’s performance depends very much, and not monotonically, on
the array size, see getOptimalDFTSize() . In the current implementation DCT of
a vector of size N is computed via DFT of a vector of size N/2 , thus the
optimal DCT size N^*\geqN can be computed as:

size_t getOptimalDCTSize(size_t N) { return 2*getOptimalDFTSize((N+1)/2); }

See also: dft() , getOptimalDFTSize() , idct()

===========================================================================
*cv-dft*

void dft(const Mat& src, Mat& dst, int flags=0, int nonzeroRows=0)~

    Performs a forward or inverse Discrete Fourier transform of 1D or 2D
    floating-point array.

                  • src – The source array, real or complex
                  • dst – The destination array, which size and type depends on
                    the flags
                  • flags –

                    Transformation flags, a combination of the following values

                      □ DFT_INVERSE do an inverse 1D or 2D transform instead of
                        the default forward transform.
                      □ DFT_SCALE scale the result: divide it by the number of
                        array elements. Normally, it is combined with
                        DFT_INVERSE

                    . * DFT_ROWS do a forward or inverse transform of every
                    individual row of the input matrix. This flag allows the
                    user to transform multiple vectors simultaneously and can
                    be used to decrease the overhead (which is sometimes
                    several times larger than the processing itself), to do 3D
                    and higher-dimensional transforms and so forth.

                      □ DFT_COMPLEX_OUTPUT then the function performs forward
                        transformation of 1D or 2D real array, the result,
                        though being a complex array, has complex-conjugate
                        symmetry ( CCS ), see the description below. Such an
                        array can be packed into real array of the same size as
    Parameters:         input, which is the fastest option and which is what
                        the function does by default. However, you may wish to
                        get the full complex array (for simpler spectrum
                        analysis etc.). Pass the flag to tell the function to
                        produce full-size complex output array.
                      □ DFT_REAL_OUTPUT then the function performs inverse
                        transformation of 1D or 2D complex array, the result is
                        normally a complex array of the same size. However, if
                        the source array has conjugate-complex symmetry (for
                        example, it is a result of forward transformation with
                        DFT_COMPLEX_OUTPUT flag), then the output is real
                        array. While the function itself does not check whether
                        the input is symmetrical or not, you can pass the flag
                        and then the function will assume the symmetry and
                        produce the real output array. Note that when the input
                        is packed real array and inverse transformation is
                        executed, the function treats the input as packed
                        complex-conjugate symmetrical array, so the output will
                        also be real array
                  • nonzeroRows – When the parameter \ne 0 , the function
                    assumes that only the first nonzeroRows rows of the input
                    array ( DFT_INVERSE is not set) or only the first
                    nonzeroRows of the output array ( DFT_INVERSE is set)
                    contain non-zeros, thus the function can handle the rest of
                    the rows more efficiently and thus save some time. This
                    technique is very useful for computing array
                    cross-correlation or convolution using DFT

Forward Fourier transform of 1D vector of N elements:

Y = F^{(N)} * X,

where F^{(N)}_{jk}=\exp(-2\pi i j k/N) and i=\sqrt{-1} Inverse Fourier
transform of 1D vector of N elements:

\begin{array}{l} X'= \left (F^{(N)} \right )^{-1} * Y = \left (F^{(N)} \
right )^* * y \\ X = (1/N) * X, \end{array}

where F^*=\left(\textrm{Re}(F^{(N)})-\textrm{Im}(F^{(N)})\right)^T Forward
Fourier transform of 2D vector of M \times N elements:

Y = F^{(M)} * X * F^{(N)}

Inverse Fourier transform of 2D vector of M \times N elements:

\begin{array}{l} X'= \left (F^{(M)} \right )^* * Y * \left (F^{(N)} \
right )^* \\ X = \frac{1}{M * N} * X' \end{array}

In the case of real (single-channel) data, the packed format called CCS
(complex-conjugate-symmetrical) that was borrowed from IPL and used to
represent the result of a forward Fourier transform or input for an inverse
Fourier transform:

\begin{bmatrix} Re Y_{0,0} & Re Y_{0,1} & Im Y_{0,1} & Re Y_{0,2} & Im Y_{0,2}
& *s & Re Y_{0,N/2-1} & Im Y_{0,N/2-1} & Re Y_{0,N/2} \\ Re Y_{1,0} & Re Y_
{1,1} & Im Y_{1,1} & Re Y_{1,2} & Im Y_{1,2} & *s & Re Y_{1,N/2-1} & Im Y_
{1,N/2-1} & Re Y_{1,N/2} \\ Im Y_{1,0} & Re Y_{2,1} & Im Y_{2,1} & Re Y_{2,2} &
Im Y_{2,2} & *s & Re Y_{2,N/2-1} & Im Y_{2,N/2-1} & Im Y_{1,N/2} \\ \
hdotsfor{9} \\ Re Y_{M/2-1,0} & Re Y_{M-3,1} & Im Y_{M-3,1} & \hdotsfor{3} & Re
Y_{M-3,N/2-1} & Im Y_{M-3,N/2-1}& Re Y_{M/2-1,N/2} \\ Im Y_{M/2-1,0} & Re Y_
{M-2,1} & Im Y_{M-2,1} & \hdotsfor{3} & Re Y_{M-2,N/2-1} & Im Y_{M-2,N/2-1}& Im
Y_{M/2-1,N/2} \\ Re Y_{M/2,0} & Re Y_{M-1,1} & Im Y_{M-1,1} & \hdotsfor{3} & Re
Y_{M-1,N/2-1} & Im Y_{M-1,N/2-1}& Re Y_{M/2,N/2} \end{bmatrix}

in the case of 1D transform of real vector, the output will look as the first
row of the above matrix.

So, the function chooses the operation mode depending on the flags and size of
the input array:

  • if DFT_ROWS is set or the input array has single row or single column then
    the function performs 1D forward or inverse transform (of each row of a
    matrix when DFT_ROWS is set, otherwise it will be 2D transform.
  • if input array is real and DFT_INVERSE is not set, the function does
    forward 1D or 2D transform:
      □ when DFT_COMPLEX_OUTPUT is set then the output will be complex matrix
        of the same size as input.
      □ otherwise the output will be a real matrix of the same size as input.
        in the case of 2D transform it will use the packed format as shown
        above; in the case of single 1D transform it will look as the first row
        of the above matrix; in the case of multiple 1D transforms (when using
        DCT_ROWS flag) each row of the output matrix will look like the first
        row of the above matrix.
  • otherwise, if the input array is complex and either DFT_INVERSE or
    DFT_REAL_OUTPUT are not set then the output will be a complex array of the
    same size as input and the function will perform the forward or inverse 1D
    or 2D transform of the whole input array or each row of the input array
    independently, depending on the flags DFT_INVERSE and DFT_ROWS .
  • otherwise, i.e. when DFT_INVERSE is set, the input array is real, or it is
    complex but DFT_REAL_OUTPUT is set, the output will be a real array of the
    same size as input, and the function will perform 1D or 2D inverse
    transformation of the whole input array or each individual row, depending
    on the flags DFT_INVERSE and DFT_ROWS .

The scaling is done after the transformation if DFT_SCALE is set.

Unlike dct() , the function supports arrays of arbitrary size, but only those
arrays are processed efficiently, which sizes can be factorized in a product of
small prime numbers (2, 3 and 5 in the current implementation). Such an
efficient DFT size can be computed using getOptimalDFTSize() method.

Here is the sample on how to compute DFT-based convolution of two 2D real
arrays:

void convolveDFT(const Mat& A, const Mat& B, Mat& C)
{
    // reallocate the output array if needed
    C.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type());
    Size dftSize;
    // compute the size of DFT transform
    dftSize.width = getOptimalDFTSize(A.cols + B.cols - 1);
    dftSize.height = getOptimalDFTSize(A.rows + B.rows - 1);

    // allocate temporary buffers and initialize them with 0's
    Mat tempA(dftSize, A.type(), Scalar::all(0));
    Mat tempB(dftSize, B.type(), Scalar::all(0));

    // copy A and B to the top-left corners of tempA and tempB, respectively
    Mat roiA(tempA, Rect(0,0,A.cols,A.rows));
    A.copyTo(roiA);
    Mat roiB(tempB, Rect(0,0,B.cols,B.rows));
    B.copyTo(roiB);

    // now transform the padded A & B in-place;
    // use "nonzeroRows" hint for faster processing
    dft(tempA, tempA, 0, A.rows);
    dft(tempB, tempB, 0, B.rows);

    // multiply the spectrums;
    // the function handles packed spectrum representations well
    mulSpectrums(tempA, tempB, tempA);

    // transform the product back from the frequency domain.
    // Even though all the result rows will be non-zero,
    // we need only the first C.rows of them, and thus we
    // pass nonzeroRows == C.rows
    dft(tempA, tempA, DFT_INVERSE + DFT_SCALE, C.rows);

    // now copy the result back to C.
    tempA(Rect(0, 0, C.cols, C.rows)).copyTo(C);

    // all the temporary buffers will be deallocated automatically
}

What can be optimized in the above sample?

  • since we passed nonzeroRows \ne 0 to the forward transform calls
    and

        since we copied

    A / B to the top-left corners of tempA / tempB , respectively,

        it’s not necessary to clear the whole

    tempA and tempB ;

        it is only necessary to clear the

    tempA.cols - A.cols ( tempB.cols - B.cols )

        rightmost columns of the matrices.

  • 
    this DFT-based convolution does not have to be applied to the whole big
        arrays,

        especially if

    B is significantly smaller than A or vice versa.

        Instead, we can compute convolution by parts. For that we need to split
        the destination array

    C into multiple tiles and for each tile estimate, which parts of A and B
    are required to compute convolution in this tile. If the tiles in C are too
    small,

        the speed will decrease a lot, because of repeated work - in the
        ultimate case, when each tile in

    C is a single pixel,

        the algorithm becomes equivalent to the naive convolution algorithm. If
        the tiles are too big, the temporary arrays

    tempA and tempB become too big

        and there is also slowdown because of bad cache locality. So there is
        optimal tile size somewhere in the middle.

  • if the convolution is done by parts, since different tiles in C can be
    computed in parallel, the loop can be threaded.

All of the above improvements have been implemented in matchTemplate() and
filter2D() , therefore, by using them, you can get even better performance than
with the above theoretically optimal implementation (though, those two
functions actually compute cross-correlation, not convolution, so you will need
to “flip” the kernel or the image around the center using flip() ).

See also: dct() , getOptimalDFTSize() , mulSpectrums() , filter2D() ,
matchTemplate() , flip() , cartToPolar() , magnitude() , phase()

===========================================================================
*cv-divide*

void divide(const Mat& src1, const Mat& src2, Mat& dst, double scale=1)~

void divide(double scale, const Mat& src2, Mat& dst)

void divide(const MatND& src1, const MatND& src2, MatND& dst, double scale=1)

void divide(double scale, const MatND& src2, MatND& dst)

    Performs per-element division of two arrays or a scalar by an array.

                  • src1 – The first source array
                  • src2 – The second source array; should have the same size
    Parameters:     and same type as src1
                  • scale – Scale factor
                  • dst – The destination array; will have the same size and
                    same type as src2

The functions divide divide one array by another:

\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}

or a scalar by array, when there is no src1 :

\texttt{dst(I) = saturate(scale/src2(I))}

The result will have the same type as src1 . When src2(I)=0 , dst(I)=0 too.

See also: multiply() , add() , subtract() , Matrix Expressions

===========================================================================
*cv-determinant*

double determinant(const Mat& mtx)~

    Returns determinant of a square floating-point matrix.

    Parameter: mtx – The input matrix; must have CV_32FC1 or CV_64FC1 type and
               square size

The function determinant computes and returns determinant of the specified
matrix. For small matrices ( mtx.cols=mtx.rows<=3 ) the direct method is used;
for larger matrices the function uses LU factorization.

For symmetric positive-determined matrices, it is also possible to compute SVD
() : mtx=U * W * V^T and then calculate the determinant as a
product of the diagonal elements of W .

See also: SVD() , trace() , invert() , solve() , Matrix Expressions

===========================================================================
*cv-eigen*

bool eigen(const Mat& src, Mat& eigenvalues, int lowindex=-1, int highindex=-1)
    ~

bool eigen(const Mat& src, Mat& eigenvalues, Mat& eigenvectors, int lowindex=-1
    , int highindex=-1)

    Computes eigenvalues and eigenvectors of a symmetric matrix.

                  • src – The input matrix; must have CV_32FC1 or CV_64FC1
                    type, square size and be symmetric: src^T=\texttt
                    {src}
                  • eigenvalues – The output vector of eigenvalues of the same
                    type as src ; The eigenvalues are stored in the descending
                    order.
    Parameters:   • eigenvectors – The output matrix of eigenvectors; It will
                    have the same size and the same type as src ; The
                    eigenvectors are stored as subsequent matrix rows, in the
                    same order as the corresponding eigenvalues
                  • lowindex – Optional index of largest eigenvalue/-vector to
                    calculate. (See below.)
                  • highindex – Optional index of smallest eigenvalue/-vector
                    to calculate. (See below.)

The functions eigen compute just eigenvalues, or eigenvalues and eigenvectors
of symmetric matrix src :

src*eigenvectors(i,:)' = eigenvalues(i)*eigenvectors(i,:)' (in MATLAB notation)

If either low- or highindex is supplied the other is required, too. Indexing is
0-based. Example: To calculate the largest eigenvector/-value set lowindex =
highindex = 0. For legacy reasons this function always returns a square matrix
the same size as the source matrix with eigenvectors and a vector the length of
the source matrix with eigenvalues. The selected eigenvectors/-values are
always in the first highindex - lowindex + 1 rows.

See also: SVD() , completeSymm() , PCA()

===========================================================================
*cv-exp*

void exp(const Mat& src, Mat& dst)~

void exp(const MatND& src, MatND& dst)

    Calculates the exponent of every array element.

                  • src – The source array
    Parameters:   • dst – The destination array; will have the same size and
                    same type as src

The function exp calculates the exponent of every element of the input array:

dst [I] = e^{ src }(I)

The maximum relative error is about 7 \times 10^{-6} for single-precision and
less than 10^{-10} for double-precision. Currently, the function converts
denormalized values to zeros on output. Special values (NaN, \pm \infty ) are
not handled.

See also: log() , cartToPolar() , polarToCart() , phase() , pow() , sqrt() ,
magnitude()

===========================================================================
*cv-extractImageCOI*

void extractImageCOI(const CvArr* src, Mat& dst, int coi=-1)~

    Extract the selected image channel

                  • src – The source array. It should be a pointer to CvMat or
                    IplImage
                  • dst – The destination array; will have single-channel, and
    Parameters:     the same size and the same depth as src
                  • coi – If the parameter is >=0 , it specifies the channel to
                    extract; If it is <0 , src must be a pointer to IplImage
                    with valid COI set - then the selected COI is extracted.

The function extractImageCOI is used to extract image COI from an old-style
array and put the result to the new-style C++ matrix. As usual, the destination
matrix is reallocated using Mat::create if needed.

To extract a channel from a new-style matrix, use mixChannels() or split() See
also: mixChannels() , split() , merge() , cvarrToMat() , cvSetImageCOI() ,
cvGetImageCOI()

===========================================================================
*cv-fastAtan2*

float fastAtan2(float y, float x)~

    Calculates the angle of a 2D vector in degrees

    Parameters:   • x – x-coordinate of the vector
                  • y – y-coordinate of the vector

The function fastAtan2 calculates the full-range angle of an input 2D vector.
The angle is measured in degrees and varies from 0^\circ to 360^\circ . The
accuracy is about 0.3^\circ .

===========================================================================
*cv-flip*

void flip(const Mat& src, Mat& dst, int flipCode)~

    Flips a 2D array around vertical, horizontal or both axes.

                  • src – The source array
                  • dst – The destination array; will have the same size and
                    same type as src
    Parameters:   • flipCode – Specifies how to flip the array: 0 means
                    flipping around the x-axis, positive (e.g., 1) means
                    flipping around y-axis, and negative (e.g., -1) means
                    flipping around both axes. See also the discussion below
                    for the formulas.

The function flip flips the array in one of three different ways (row and
column indices are 0-based):

dst _{ij} = \forkthree{src_{src.rows-i-1,j} }{if \
texttt{flipCode} = 0}{ src _{i, src.cols -j-1}}{if \texttt
{flipCode} > 0}{ src _{ src.rows -i-1, src.cols
-j-1}}{if flipCode < 0}

The example scenarios of function use are:

  • vertical flipping of the image ( flipCode = 0 ) to switch between
    top-left and bottom-left image origin, which is a typical operation in
    video processing in Windows.
  • horizontal flipping of the image with subsequent horizontal shift and
    absolute difference calculation to check for a vertical-axis symmetry ( \
    texttt{flipCode} > 0 )
  • simultaneous horizontal and vertical flipping of the image with subsequent
    shift and absolute difference calculation to check for a central symmetry (
    flipCode < 0 )
  • reversing the order of 1d point arrays ( flipCode > 0 or \texttt
    {flipCode} = 0 )

See also: transpose() , repeat() , completeSymm()

===========================================================================
*cv-gemm*

void gemm(const Mat& src1, const Mat& src2, double alpha, const Mat& src3,
    double beta, Mat& dst, int flags=0)~

    Performs generalized matrix multiplication.

                  • src1 – The first multiplied input matrix; should have
                    CV_32FC1 , CV_64FC1 , CV_32FC2 or CV_64FC2 type
                  • src2 – The second multiplied input matrix; should have the
                    same type as src1
                  • alpha – The weight of the matrix product
                  • src3 – The third optional delta matrix added to the matrix
                    product; should have the same type as src1 and src2
                  • beta – The weight of src3
    Parameters:   • dst – The destination matrix; It will have the proper size
                    and the same type as input matrices
                  • flags –

                    Operation flags:

                      □ GEMM_1_T transpose src1
                      □ GEMM_2_T transpose src2
                      □ GEMM_3_T transpose src3

The function performs generalized matrix multiplication and similar to the
corresponding functions *gemm in BLAS level 3. For example, gemm(src1, src2,
alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T) corresponds to

dst = alpha * src1 ^T * src2 + \
texttt{beta} * src3 ^T

The function can be replaced with a matrix expression, e.g. the above call can
be replaced with:

dst = alpha*src1.t()*src2 + beta*src3.t();

See also: mulTransposed() , transform() , Matrix Expressions

===========================================================================
*cv-getConvertElem*

ConvertData getConvertElem(int fromType, int toType)~

ConvertScaleData getConvertScaleElem(int fromType, int toType)~

typedef void (*ConvertData)(const void* from, void* to, int cn)~

typedef void (*ConvertScaleData)(const void* from, void* to, int cn, double
    alpha, double beta)~

    Returns conversion function for a single pixel

                  • fromType – The source pixel type
                  • toType – The destination pixel type
                  • from – Callback parameter: pointer to the input pixel
                  • to – Callback parameter: pointer to the output pixel
    Parameters:   • cn – Callback parameter: the number of channels; can be
                    arbitrary, 1, 100, 100000, ...
                  • alpha – ConvertScaleData callback optional parameter: the
                    scale factor
                  • beta – ConvertScaleData callback optional parameter: the
                    delta or offset

The functions getConvertElem and getConvertScaleElem return pointers to the
functions for converting individual pixels from one type to another. While the
main function purpose is to convert single pixels (actually, for converting
sparse matrices from one type to another), you can use them to convert the
whole row of a dense matrix or the whole matrix at once, by setting cn =
matrix.cols*matrix.rows*matrix.channels() if the matrix data is continuous.

See also: Mat::convertTo() , MatND::convertTo() , SparseMat::convertTo()

===========================================================================
*cv-getOptimalDFTSize*

int getOptimalDFTSize(int vecsize)~

    Returns optimal DFT size for a given vector size.

    Parameter: vecsize – Vector size

DFT performance is not a monotonic function of a vector size, therefore, when
you compute convolution of two arrays or do a spectral analysis of array, it
usually makes sense to pad the input data with zeros to get a bit larger array
that can be transformed much faster than the original one. Arrays, which size
is a power-of-two (2, 4, 8, 16, 32, ...) are the fastest to process, though,
the arrays, which size is a product of 2’s, 3’s and 5’s (e.g. 300 = 5*5*3*2*2),
are also processed quite efficiently.

The function getOptimalDFTSize returns the minimum number N that is greater
than or equal to vecsize , such that the DFT of a vector of size N can be
computed efficiently. In the current implementation N=2^p \times 3^q \times 5^r
, for some p , q , r .

The function returns a negative number if vecsize is too large (very close to
INT_MAX ).

While the function cannot be used directly to estimate the optimal vector size
for DCT transform (since the current DCT implementation supports only even-size
vectors), it can be easily computed as getOptimalDFTSize((vecsize+1)/2)*2 .

See also: dft() , dct() , idft() , idct() , mulSpectrums()

===========================================================================
*cv-idct*

void idct(const Mat& src, Mat& dst, int flags=0)~

    Computes inverse Discrete Cosine Transform of a 1D or 2D array

                  • src – The source floating-point single-channel array
    Parameters:   • dst – The destination array. Will have the same size and
                    same type as src
                  • flags – The operation flags.

idct(src, dst, flags) is equivalent to dct(src, dst, flags | DCT_INVERSE) . See
dct() for details.

See also: dct() , dft() , idft() , getOptimalDFTSize()

===========================================================================
*cv-idft*

void idft(const Mat& src, Mat& dst, int flags=0, int outputRows=0)~

    Computes inverse Discrete Fourier Transform of a 1D or 2D array

                  • src – The source floating-point real or complex array
                  • dst – The destination array, which size and type depends on
                    the flags
    Parameters:   • flags – The operation flags. See dft()
                  • nonzeroRows – The number of dst rows to compute. The rest
                    of the rows will have undefined content. See the
                    convolution sample in dft() description

idft(src, dst, flags) is equivalent to dct(src, dst, flags | DFT_INVERSE) . See
dft() for details. Note, that none of dft and idft scale the result by default.
Thus, you should pass DFT_SCALE to one of dft or idft explicitly to make these
transforms mutually inverse.

See also: dft() , dct() , idct() , mulSpectrums() , getOptimalDFTSize()

===========================================================================
*cv-inRange*

void inRange(const Mat& src, const Mat& lowerb, const Mat& upperb, Mat& dst)~

void inRange(const Mat& src, const Scalar& lowerb, const Scalar& upperb, Mat&
    dst)

void inRange(const MatND& src, const MatND& lowerb, const MatND& upperb, MatND&
    dst)

void inRange(const MatND& src, const Scalar& lowerb, const Scalar& upperb,
    MatND& dst)

    Checks if array elements lie between the elements of two other arrays.

                  • src – The first source array
                  • lowerb – The inclusive lower boundary array of the same
                    size and type as src
    Parameters:   • upperb – The exclusive upper boundary array of the same
                    size and type as src
                  • dst – The destination array, will have the same size as src
                    and CV_8U type

The functions inRange do the range check for every element of the input array:

dst (I)= lowerb (I)_0 \leq src (I)_0 < \texttt
{upperb} (I)_0

for single-channel arrays,

dst (I)= lowerb (I)_0 \leq src (I)_0 < \texttt
{upperb} (I)_0 \land lowerb (I)_1 \leq src (I)_1 < \texttt
{upperb} (I)_1

for two-channel arrays and so forth. dst (I) is set to 255 (all 1 -bits) if src
(I) is within the specified range and 0 otherwise.

===========================================================================
*cv-invert*

double invert(const Mat& src, Mat& dst, int method=DECOMP_LU)~

    Finds the inverse or pseudo-inverse of a matrix

                  • src – The source floating-point M \times N matrix
                  • dst – The destination matrix; will have N \times M size and
                    the same type as src
                  • flags –

    Parameters:     The inversion method :

                      □ DECOMP_LU Gaussian elimination with optimal pivot
                        element chosen
                      □ DECOMP_SVD Singular value decomposition (SVD) method
                      □ DECOMP_CHOLESKY Cholesky decomposion. The matrix must
                        be symmetrical and positively defined

The function invert inverts matrix src and stores the result in dst . When the
matrix src is singular or non-square, the function computes the pseudo-inverse
matrix, i.e. the matrix dst , such that \|src * dst - I\|
is minimal.

In the case of DECOMP_LU method, the function returns the src determinant ( src
must be square). If it is 0, the matrix is not inverted and dst is filled with
zeros.

In the case of DECOMP_SVD method, the function returns the inversed condition
number of src (the ratio of the smallest singular value to the largest singular
value) and 0 if src is singular. The SVD method calculates a pseudo-inverse
matrix if src is singular.

Similarly to DECOMP_LU , the method DECOMP_CHOLESKY works only with
non-singular square matrices. In this case the function stores the inverted
matrix in dst and returns non-zero, otherwise it returns 0.

See also: solve() , SVD()

===========================================================================
*cv-log*

void log(const Mat& src, Mat& dst)~

void log(const MatND& src, MatND& dst)

    Calculates the natural logarithm of every array element.

                  • src – The source array
    Parameters:   • dst – The destination array; will have the same size and
                    same type as src

The function log calculates the natural logarithm of the absolute value of
every element of the input array:

dst (I) = \fork{\log |src(I)|}{if $src(I) \ne 0$ }{\
texttt{C}}{otherwise}

Where C is a large negative number (about -700 in the current implementation).
The maximum relative error is about 7 \times 10^{-6} for single-precision input
and less than 10^{-10} for double-precision input. Special values (NaN, \pm \
infty ) are not handled.

See also: exp() , cartToPolar() , polarToCart() , phase() , pow() , sqrt() ,
magnitude()

===========================================================================
*cv-LUT*

void LUT(const Mat& src, const Mat& lut, Mat& dst)~

    Performs a look-up table transform of an array.

                  • src – Source array of 8-bit elements
                  • lut – Look-up table of 256 elements. In the case of
                    multi-channel source array, the table should either have a
    Parameters:     single channel (in this case the same table is used for all
                    channels) or the same number of channels as in the source
                    array
                  • dst – Destination array; will have the same size and the
                    same number of channels as src , and the same depth as lut

The function LUT fills the destination array with values from the look-up
table. Indices of the entries are taken from the source array. That is, the
function processes each element of src as follows:

dst (I) \leftarrow lut(src(I) + d)

where

d = \fork{0}{if src has depth \texttt{CV\_8U}}{128}{if src
has depth \texttt{CV\_8S}}

See also: convertScaleAbs() , Mat::convertTo

===========================================================================
*cv-magnitude*

void magnitude(const Mat& x, const Mat& y, Mat& magnitude)~

    Calculates magnitude of 2D vectors.

                  • x – The floating-point array of x-coordinates of the
                    vectors
    Parameters:   • y – The floating-point array of y-coordinates of the
                    vectors; must have the same size as x
                  • dst – The destination array; will have the same size and
                    same type as x

The function magnitude calculates magnitude of 2D vectors formed from the
corresponding elements of x and y arrays:

dst (I) = \sqrt{x(I)^2 + y(I)^2}

See also: cartToPolar() , polarToCart() , phase() , sqrt()

===========================================================================
*cv-Mahalanobis*

double Mahalanobis(const Mat& vec1, const Mat& vec2, const Mat& icovar)~

    Calculates the Mahalanobis distance between two vectors.

                  • vec1 – The first 1D source vector
    Parameters:   • vec2 – The second 1D source vector
                  • icovar – The inverse covariance matrix

The function cvMahalonobis calculates and returns the weighted distance between
two vectors:

d( vec1 , vec2 )= \sqrt{\sum_{i,j}{icovar(i,j)*
(vec1(I)-vec2(I))*(vec1(j)-vec2(j))} }

The covariance matrix may be calculated using the calcCovarMatrix() function
and then inverted using the invert() function (preferably using DECOMP _ SVD
method, as the most accurate).

===========================================================================
*cv-max*

Mat_Expr<...> max(const Mat& src1, const Mat& src2)~

Mat_Expr<...> max(const Mat& src1, double value)

Mat_Expr<...> max(double value, const Mat& src1)

void max(const Mat& src1, const Mat& src2, Mat& dst)

void max(const Mat& src1, double value, Mat& dst)

void max(const MatND& src1, const MatND& src2, MatND& dst)

void max(const MatND& src1, double value, MatND& dst)

    Calculates per-element maximum of two arrays or array and a scalar

                  • src1 – The first source array
                  • src2 – The second source array of the same size and type as
    Parameters:     src1
                  • value – The real scalar value
                  • dst – The destination array; will have the same size and
                    type as src1

The functions max compute per-element maximum of two arrays:

dst (I)= \max ( src1 (I), src2 (I))

or array and a scalar:

dst (I)= \max ( src1 (I), value )

In the second variant, when the source array is multi-channel, each channel is
compared with value independently.

The first 3 variants of the function listed above are actually a part of Matrix
Expressions , they return the expression object that can be further
transformed, or assigned to a matrix, or passed to a function etc.

See also: min() , compare() , inRange() , minMaxLoc() , Matrix Expressions

===========================================================================
*cv-mean*

Scalar mean(const Mat& mtx)~

Scalar mean(const Mat& mtx, const Mat& mask)

Scalar mean(const MatND& mtx)

Scalar mean(const MatND& mtx, const MatND& mask)

    Calculates average (mean) of array elements

                  • mtx – The source array; it should have 1 to 4 channels (so
    Parameters:     that the result can be stored in Scalar() )
                  • mask – The optional operation mask

The functions mean compute mean value M of array elements, independently for
each channel, and return it:

\begin{array}{l} N = \sum _{I: \; mask (I) \ne 0} 1 \\ M_c = \left ( \
sum _{I: \; mask (I) \ne 0}{ mtx (I)_c} \right )/N \end
{array}

When all the mask elements are 0’s, the functions return Scalar::all(0) .

See also: countNonZero() , meanStdDev() , norm() , minMaxLoc()

===========================================================================
*cv-meanStdDev*

void meanStdDev(const Mat& mtx, Scalar& mean, Scalar& stddev, const Mat& mask=
    Mat())~

void meanStdDev(const MatND& mtx, Scalar& mean, Scalar& stddev, const MatND&
    mask=MatND())

    Calculates mean and standard deviation of array elements

                  • mtx – The source array; it should have 1 to 4 channels (so
                    that the results can be stored in Scalar() ‘s)
    Parameters:   • mean – The output parameter: computed mean value
                  • stddev – The output parameter: computed standard deviation
                  • mask – The optional operation mask

The functions meanStdDev compute the mean and the standard deviation M of array
elements, independently for each channel, and return it via the output
parameters:

\begin{array}{l} N = \sum _{I, mask (I) \ne 0} 1 \\ mean _c =
\frac{\sum_{ I: \; mask(I) \ne 0} src (I)_c}{N} \\ \texttt
{stddev} _c = \sqrt{\sum_{ I: \; mask(I) \ne 0} \left ( src
(I)_c - mean _c \right )^2} \end{array}

When all the mask elements are 0’s, the functions return mean=stddev=
Scalar::all(0) . Note that the computed standard deviation is only the diagonal
of the complete normalized covariance matrix. If the full matrix is needed, you
can reshape the multi-channel array M \times N to the single-channel array M*N
\times mtx.channels() (only possible when the matrix is continuous)
and then pass the matrix to calcCovarMatrix() .

See also: countNonZero() , mean() , norm() , minMaxLoc() , calcCovarMatrix()

===========================================================================
*cv-merge*

void merge(const Mat* mv, size_t count, Mat& dst)~

void merge(const vector<Mat>& mv, Mat& dst)

void merge(const MatND* mv, size_t count, MatND& dst)

void merge(const vector<MatND>& mv, MatND& dst)

    Composes a multi-channel array from several single-channel arrays.

                  • mv – The source array or vector of the single-channel
                    matrices to be merged. All the matrices in mv must have the
                    same size and the same type
    Parameters:   • count – The number of source matrices when mv is a plain C
                    array; must be greater than zero
                  • dst – The destination array; will have the same size and
                    the same depth as mv[0] , the number of channels will match
                    the number of source matrices

The functions merge merge several single-channel arrays (or rather interleave
their elements) to make a single multi-channel array.

dst (I)_c = mv [c](I)

The function split() does the reverse operation and if you need to merge
several multi-channel images or shuffle channels in some other advanced way,
use mixChannels() See also: mixChannels() , split() , reshape()

===========================================================================
*cv-min*

Mat_Expr<...> min(const Mat& src1, const Mat& src2)~

Mat_Expr<...> min(const Mat& src1, double value)

Mat_Expr<...> min(double value, const Mat& src1)

void min(const Mat& src1, const Mat& src2, Mat& dst)

void min(const Mat& src1, double value, Mat& dst)

void min(const MatND& src1, const MatND& src2, MatND& dst)

void min(const MatND& src1, double value, MatND& dst)

    Calculates per-element minimum of two arrays or array and a scalar

                  • src1 – The first source array
                  • src2 – The second source array of the same size and type as
    Parameters:     src1
                  • value – The real scalar value
                  • dst – The destination array; will have the same size and
                    type as src1

The functions min compute per-element minimum of two arrays:

dst (I)= \min ( src1 (I), src2 (I))

or array and a scalar:

dst (I)= \min ( src1 (I), value )

In the second variant, when the source array is multi-channel, each channel is
compared with value independently.

The first 3 variants of the function listed above are actually a part of Matrix
Expressions , they return the expression object that can be further
transformed, or assigned to a matrix, or passed to a function etc.

See also: max() , compare() , inRange() , minMaxLoc() , Matrix Expressions

===========================================================================
*cv-minMaxLoc*

void minMaxLoc(const Mat& src, double* minVal, double* maxVal=0, Point* minLoc=
    0, Point* maxLoc=0, const Mat& mask=Mat())~

void minMaxLoc(const MatND& src, double* minVal, double* maxVal, int* minIdx=0,
    int* maxIdx=0, const MatND& mask=MatND())

void minMaxLoc(const SparseMat& src, double* minVal, double* maxVal, int*
    minIdx=0, int* maxIdx=0)

    Finds global minimum and maximum in a whole array or sub-array

                  • src – The source single-channel array
                  • minVal – Pointer to returned minimum value; NULL if not
                    required
                  • maxVal – Pointer to returned maximum value; NULL if not
                    required
                  • minLoc – Pointer to returned minimum location (in 2D case);
                    NULL if not required
    Parameters:   • maxLoc – Pointer to returned maximum location (in 2D case);
                    NULL if not required
                  • minIdx – Pointer to returned minimum location (in nD case);
                    NULL if not required, otherwise must point to an array of
                    src.dims elements and the coordinates of minimum element in
                    each dimensions will be stored sequentially there.
                  • maxIdx – Pointer to returned maximum location (in nD case);
                    NULL if not required
                  • mask – The optional mask used to select a sub-array

The functions ninMaxLoc find minimum and maximum element values and their
positions. The extremums are searched across the whole array, or, if mask is
not an empty array, in the specified array region.

The functions do not work with multi-channel arrays. If you need to find
minimum or maximum elements across all the channels, use reshape() first to
reinterpret the array as single-channel. Or you may extract the particular
channel using extractImageCOI() or mixChannels() or split() .

in the case of a sparse matrix the minimum is found among non-zero elements
only.

See also: max() , min() , compare() , inRange() , extractImageCOI() ,
mixChannels() , split() , reshape() .

===========================================================================
*cv-mixChannels*

void mixChannels(const Mat* srcv, int nsrc, Mat* dstv, int ndst, const int*
    fromTo, size_t npairs)~

void mixChannels(const MatND* srcv, int nsrc, MatND* dstv, int ndst, const int*
    fromTo, size_t npairs)

void mixChannels(const vector<Mat>& srcv, vector<Mat>& dstv, const int* fromTo,
    int npairs)

void mixChannels(const vector<MatND>& srcv, vector<MatND>& dstv, const int*
    fromTo, int npairs)

    Copies specified channels from input arrays to the specified channels of
    output arrays

                  • srcv – The input array or vector of matrices. All the
                    matrices must have the same size and the same depth
                  • nsrc – The number of elements in srcv
                  • dstv – The output array or vector of matrices. All the
                    matrices must be allocated , their size and depth must be
                    the same as in srcv[0]
                  • ndst – The number of elements in dstv
                  • fromTo – The array of index pairs, specifying which
    Parameters:     channels are copied and where. fromTo[k*2] is the 0-based
                    index of the input channel in srcv and fromTo[k*2+1] is the
                    index of the output channel in dstv . Here the continuous
                    channel numbering is used, that is, the first input image
                    channels are indexed from 0 to srcv[0].channels()-1 , the
                    second input image channels are indexed from srcv
                    [0].channels() to srcv[0].channels() + srcv[1].channels()-1
                    etc., and the same scheme is used for the output image
                    channels. As a special case, when fromTo[k*2] is negative,
                    the corresponding output channel is filled with zero.

    npairs

The functions mixChannels provide an advanced mechanism for shuffling image
channels. split() and merge() and some forms of cvtColor() are partial cases of
mixChannels .

As an example, this code splits a 4-channel RGBA image into a 3-channel BGR
(i.e. with R and B channels swapped) and separate alpha channel image:

Mat rgba( 100, 100, CV_8UC4, Scalar(1,2,3,4) );
Mat bgr( rgba.rows, rgba.cols, CV_8UC3 );
Mat alpha( rgba.rows, rgba.cols, CV_8UC1 );

// forming array of matrices is quite efficient operations,
// because the matrix data is not copied, only the headers
Mat out[] = { bgr, alpha };
// rgba[0] -> bgr[2], rgba[1] -> bgr[1],
// rgba[2] -> bgr[0], rgba[3] -> alpha[0]
int from_to[] = { 0,2,  1,1,  2,0,  3,3 };
mixChannels( &rgba, 1, out, 2, from_to, 4 );

Note that, unlike many other new-style C++ functions in OpenCV (see the
introduction section and Mat::create() ), mixChannels requires the destination
arrays be pre-allocated before calling the function.

See also: split() , merge() , cvtColor()

===========================================================================
*cv-mulSpectrums*

void mulSpectrums(const Mat& src1, const Mat& src2, Mat& dst, int flags, bool
    conj=false)~

    Performs per-element multiplication of two Fourier spectrums.

                  • src1 – The first source array
                  • src2 – The second source array; must have the same size and
                    the same type as src1
                  • dst – The destination array; will have the same size and
    Parameters:     the same type as src1
                  • flags – The same flags as passed to dft() ; only the flag
                    DFT_ROWS is checked for
                  • conj – The optional flag that conjugate the second source
                    array before the multiplication (true) or not (false)

The function mulSpectrums performs per-element multiplication of the two
CCS-packed or complex matrices that are results of a real or complex Fourier
transform.

The function, together with dft() and idft() , may be used to calculate
convolution (pass conj=false ) or correlation (pass conj=false ) of two arrays
rapidly. When the arrays are complex, they are simply multiplied (per-element)
with optional conjugation of the second array elements. When the arrays are
real, they assumed to be CCS-packed (see dft() for details).

===========================================================================
*cv-multiply*

void multiply(const Mat& src1, const Mat& src2, Mat& dst, double scale=1)~

void multiply(const MatND& src1, const MatND& src2, MatND& dst, double scale=1)

    Calculates the per-element scaled product of two arrays

                  • src1 – The first source array
                  • src2 – The second source array of the same size and the
    Parameters:     same type as src1
                  • dst – The destination array; will have the same size and
                    the same type as src1
                  • scale – The optional scale factor

The function multiply calculates the per-element product of two arrays:

dst (I)= saturate ( scale * src1 (I) \
cdot src2 (I))

There is also Matrix Expressions -friendly variant of the first function, see
Mat::mul() .

If you are looking for a matrix product, not per-element product, see gemm() .

See also: add() , substract() , divide() , Matrix Expressions , scaleAdd() ,
addWeighted() , accumulate() , accumulateProduct() , accumulateSquare() ,
Mat::convertTo()

===========================================================================
*cv-mulTransposed*

void mulTransposed(const Mat& src, Mat& dst, bool aTa, const Mat& delta=Mat(),
    double scale=1, int rtype=-1)~

    Calculates the product of a matrix and its transposition.

                  • src – The source matrix
                  • dst – The destination square matrix
                  • aTa – Specifies the multiplication ordering; see the
                    description below
                  • delta – The optional delta matrix, subtracted from src
                    before the multiplication. When the matrix is empty ( delta
                    =Mat() ), it’s assumed to be zero, i.e. nothing is
                    subtracted, otherwise if it has the same size as src , then
    Parameters:     it’s simply subtracted, otherwise it is “repeated” (see
                    repeat() ) to cover the full src and then subtracted. Type
                    of the delta matrix, when it’s not empty, must be the same
                    as the type of created destination matrix, see the rtype
                    description
                  • scale – The optional scale factor for the matrix product
                  • rtype – When it’s negative, the destination matrix will
                    have the same type as src . Otherwise, it will have type=
                    CV_MAT_DEPTH(rtype) , which should be either CV_32F or
                    CV_64F

The function mulTransposed calculates the product of src and its transposition:

dst = scale ( src - delta )^T ( \texttt
{src} - delta )

if aTa=true , and

dst = scale ( src - delta ) ( src
- delta )^T

otherwise. The function is used to compute covariance matrix and with zero
delta can be used as a faster substitute for general matrix product A*B when B=
A^T .

See also: calcCovarMatrix() , gemm() , repeat() , reduce()

===========================================================================
*cv-norm*

double norm(const Mat& src1, int normType=NORM_L2)~

double norm(const Mat& src1, const Mat& src2, int normType=NORM_L2)

double norm(const Mat& src1, int normType, const Mat& mask)

double norm(const Mat& src1, const Mat& src2, int normType, const Mat& mask)

double norm(const MatND& src1, int normType=NORM_L2, const MatND& mask=MatND())

double norm(const MatND& src1, const MatND& src2, int normType=NORM_L2, const
    MatND& mask=MatND())

double norm(const SparseMat& src, int normType)

    Calculates absolute array norm, absolute difference norm, or relative
    difference norm.

                  • src1 – The first source array
                  • src2 – The second source array of the same size and the
    Parameters:     same type as src1
                  • normType – Type of the norm; see the discussion below
                  • mask – The optional operation mask

The functions norm calculate the absolute norm of src1 (when there is no src2
):

norm = \forkthree{\|src1\|_{L_{\infty}} = \max _I | src1 (I)
|}{if $normType = \texttt{NORM\_INF}$ }{ \| src1 \| _{L_1} =
\sum _I | src1 (I)|}{if $normType = \texttt{NORM\_L1}$ }{ \|
src1 \| _{L_2} = \sqrt{\sum_I src1(I)^2} }{if $\texttt
{normType} = \texttt{NORM\_L2}$ }

or an absolute or relative difference norm if src2 is there:

norm = \forkthree{\|src1-src2\|_{L_{\infty}} = \max _I | \
texttt{src1} (I) - src2 (I)|}{if $normType = \texttt{NORM\
_INF}$ }{ \| src1 - src2 \| _{L_1} = \sum _I | src1
(I) - src2 (I)|}{if $normType = \texttt{NORM\_L1}$ }{ \| \
texttt{src1} - src2 \| _{L_2} = \sqrt{\sum_I (src1(I) - \
texttt{src2}(I))^2} }{if $normType = \texttt{NORM\_L2}$ }

or

norm = \forkthree{\frac{\|src1-src2\|_{L_{\infty}} }{\|\
texttt{src2}\|_{L_{\infty}} }}{if $normType = \texttt{NORM\_RELATIVE\
_INF}$ }{ \frac{\|src1-src2\|_{L_1} }{\|src2\|_
{L_1}} }{if $normType = \texttt{NORM\_RELATIVE\_L1}$ }{ \frac{\|\
texttt{src1}-src2\|_{L_2} }{\|src2\|_{L_2}} }{if $\texttt
{normType} = \texttt{NORM\_RELATIVE\_L2}$ }

The functions norm return the calculated norm.

When there is mask parameter, and it is not empty (then it should have type
CV_8U and the same size as src1 ), the norm is computed only over the specified
by the mask region.

A multiple-channel source arrays are treated as a single-channel, that is, the
results for all channels are combined.

===========================================================================
*cv-normalize*

void normalize(const Mat& src, Mat& dst, double alpha=1, double beta=0, int
    normType=NORM_L2, int rtype=-1, const Mat& mask=Mat())~

void normalize(const MatND& src, MatND& dst, double alpha=1, double beta=0, int
    normType=NORM_L2, int rtype=-1, const MatND& mask=MatND())

void normalize(const SparseMat& src, SparseMat& dst, double alpha, int normType
    )

    Normalizes array’s norm or the range

                  • src – The source array
                  • dst – The destination array; will have the same size as src
                  • alpha – The norm value to normalize to or the lower range
                    boundary in the case of range normalization
                  • beta – The upper range boundary in the case of range
    Parameters:     normalization; not used for norm normalization
                  • normType – The normalization type, see the discussion
                  • rtype – When the parameter is negative, the destination
                    array will have the same type as src , otherwise it will
                    have the same number of channels as src and the depth =
                    CV_MAT_DEPTH(rtype)
                  • mask – The optional operation mask

The functions normalize scale and shift the source array elements, so that

\| dst \| _{L_p}= alpha

(where p=\infty , 1 or 2) when normType=NORM_INF , NORM_L1 or NORM_L2 , or so
that

\min _I dst (I)= alpha , \, \, \max _I dst (I)= \
texttt{beta}

when normType=NORM_MINMAX (for dense arrays only).

The optional mask specifies the sub-array to be normalize, that is, the norm or
min-n-max are computed over the sub-array and then this sub-array is modified
to be normalized. If you want to only use the mask to compute the norm or
min-max, but modify the whole array, you can use norm() and Mat::convertScale()
/ MatND::convertScale() /cross{SparseMat::convertScale} separately.

in the case of sparse matrices, only the non-zero values are analyzed and
transformed. Because of this, the range transformation for sparse matrices is
not allowed, since it can shift the zero level.

See also: norm() , Mat::convertScale() , MatND::convertScale() ,
SparseMat::convertScale()

===========================================================================
*cv-PCA*

===========================================================================


Class for Principal Component Analysis

class PCA
{
public:
    // default constructor
    PCA();
    // computes PCA for a set of vectors stored as data rows or columns.
    PCA(const Mat& data, const Mat& mean, int flags, int maxComponents=0);
    // computes PCA for a set of vectors stored as data rows or columns
    PCA& operator()(const Mat& data, const Mat& mean, int flags, int maxComponents=0);
    // projects vector into the principal components space
    Mat project(const Mat& vec) const;
    void project(const Mat& vec, Mat& result) const;
    // reconstructs the vector from its PC projection
    Mat backProject(const Mat& vec) const;
    void backProject(const Mat& vec, Mat& result) const;

    // eigenvectors of the PC space, stored as the matrix rows
    Mat eigenvectors;
    // the corresponding eigenvalues; not used for PCA compression/decompression
    Mat eigenvalues;
    // mean vector, subtracted from the projected vector
    // or added to the reconstructed vector
    Mat mean;
};

The class PCA is used to compute the special basis for a set of vectors. The
basis will consist of eigenvectors of the covariance matrix computed from the
input set of vectors. And also the class PCA can transform vectors to/from the
new coordinate space, defined by the basis. Usually, in this new coordinate
system each vector from the original set (and any linear combination of such
vectors) can be quite accurately approximated by taking just the first few its
components, corresponding to the eigenvectors of the largest eigenvalues of the
covariance matrix. Geometrically it means that we compute projection of the
vector to a subspace formed by a few eigenvectors corresponding to the dominant
eigenvalues of the covariation matrix. And usually such a projection is very
close to the original vector. That is, we can represent the original vector
from a high-dimensional space with a much shorter vector consisting of the
projected vector’s coordinates in the subspace. Such a transformation is also
known as Karhunen-Loeve Transform, or KLT. See http://en.wikipedia.org/wiki/
Principal_component_analysis The following sample is the function that takes
two matrices. The first one stores the set of vectors (a row per vector) that
is used to compute PCA, the second one stores another “test” set of vectors (a
row per vector) that are first compressed with PCA, then reconstructed back and
then the reconstruction error norm is computed and printed for each vector.

PCA compressPCA(const Mat& pcaset, int maxComponents,
                const Mat& testset, Mat& compressed)
{
    PCA pca(pcaset, // pass the data
            Mat(), // we do not have a pre-computed mean vector,
                   // so let the PCA engine to compute it
            CV_PCA_DATA_AS_ROW, // indicate that the vectors
                                // are stored as matrix rows
                                // (use CV_PCA_DATA_AS_COL if the vectors are
                                // the matrix columns)
            maxComponents // specify, how many principal components to retain
            );
    // if there is no test data, just return the computed basis, ready-to-use
    if( !testset.data )
        return pca;
    CV_Assert( testset.cols == pcaset.cols );

    compressed.create(testset.rows, maxComponents, testset.type());

    Mat reconstructed;
    for( int i = 0; i < testset.rows; i++ )
    {
        Mat vec = testset.row(i), coeffs = compressed.row(i);
        // compress the vector, the result will be stored
        // in the i-th row of the output matrix
        pca.project(vec, coeffs);
        // and then reconstruct it
        pca.backProject(coeffs, reconstructed);
        // and measure the error
        printf("
    }
    return pca;
}

See also: calcCovarMatrix() , mulTransposed() , SVD() , dft() , dct()

===========================================================================
*cv-PCA::PCA*

PCA::PCA()~

PCA::PCA(const Mat& data, const Mat& mean, int flags, int maxComponents=0)

    PCA constructors

                  • data – the input samples, stored as the matrix rows or as
                    the matrix columns
                  • mean – the optional mean value. If the matrix is empty (
                    Mat() ), the mean is computed from the data.
                  • flags –

                    operation flags. Currently the parameter is only used to
    Parameters:     specify the data layout.

                      □ CV_PCA_DATA_AS_ROWS Indicates that the input samples
                        are stored as matrix rows.
                      □ CV_PCA_DATA_AS_COLS Indicates that the input samples
                        are stored as matrix columns.
                  • maxComponents – The maximum number of components that PCA
                    should retain. By default, all the components are retained.

The default constructor initializes empty PCA structure. The second constructor
initializes the structure and calls PCA::operator () .

cv::PCA::operator ()~

PCA& PCA::operator()(const Mat& data, const Mat& mean, int flags, int
    maxComponents=0)~

    Performs Principal Component Analysis of the supplied dataset.

                  • data – the input samples, stored as the matrix rows or as
                    the matrix columns
                  • mean – the optional mean value. If the matrix is empty (
                    Mat() ), the mean is computed from the data.
                  • flags –

                    operation flags. Currently the parameter is only used to
    Parameters:     specify the data layout.

                      □ CV_PCA_DATA_AS_ROWS Indicates that the input samples
                        are stored as matrix rows.
                      □ CV_PCA_DATA_AS_COLS Indicates that the input samples
                        are stored as matrix columns.
                  • maxComponents – The maximum number of components that PCA
                    should retain. By default, all the components are retained.

The operator performs PCA of the supplied dataset. It is safe to reuse the same
PCA structure for multiple dataset. That is, if the structure has been
previously used with another dataset, the existing internal data is reclaimed
and the new eigenvalues , eigenvectors and mean are allocated and computed.

The computed eigenvalues are sorted from the largest to the smallest and the
corresponding eigenvectors are stored as PCA::eigenvectors rows.

===========================================================================
*cv-PCA::project*

Mat PCA::project(const Mat& vec) const~

void PCA::project(const Mat& vec, Mat& result) const

    Project vector(s) to the principal component subspace

                  • vec – the input vector(s). They have to have the same
                    dimensionality and the same layout as the input data used
                    at PCA phase. That is, if CV_PCA_DATA_AS_ROWS had been
                    specified, then vec.cols==data.cols (that’s vectors’
                    dimensionality) and vec.rows is the number of vectors to
    Parameters:     project; and similarly for the CV_PCA_DATA_AS_COLS case.
                  • result – the output vectors. Let’s now consider
                    CV_PCA_DATA_AS_COLS case. In this case the output matrix
                    will have as many columns as the number of input vectors,
                    i.e. result.cols==vec.cols and the number of rows will
                    match the number of principal components (e.g.
                    maxComponents parameter passed to the constructor).

The methods project one or more vectors to the principal component subspace,
where each vector projection is represented by coefficients in the principal
component basis. The first form of the method returns the matrix that the
second form writes to the result. So the first form can be used as a part of
expression, while the second form can be more efficient in a processing loop.

===========================================================================
*cv-PCA::backProject*

Mat PCA::backProject(const Mat& vec) const~

void PCA::backProject(const Mat& vec, Mat& result) const

    Reconstruct vectors from their PC projections.

                  • vec – Coordinates of the vectors in the principal component
                    subspace. The layout and size are the same as of
    Parameters:     PCA::project output vectors.
                  • result – The reconstructed vectors. The layout and size are
                    the same as of PCA::project input vectors.

The methods are inverse operations to PCA::project() . They take PC coordinates
of projected vectors and reconstruct the original vectors. Of course, unless
all the principal components have been retained, the reconstructed vectors will
be different from the originals, but typically the difference will be small is
if the number of components is large enough (but still much smaller than the
original vector dimensionality) - that’s why PCA is used after all.

===========================================================================
*cv-perspectiveTransform*

void perspectiveTransform(const Mat& src, Mat& dst, const Mat& mtx)~

    Performs perspective matrix transformation of vectors.

                  • src – The source two-channel or three-channel
                    floating-point array; each element is 2D/3D vector to be
    Parameters:     transformed
                  • dst – The destination array; it will have the same size and
                    same type as src
                  • mtx – 3\times 3 or 4 \times 4 transformation matrix

The function perspectiveTransform transforms every element of src , by treating
it as 2D or 3D vector, in the following way (here 3D vector transformation is
shown; in the case of 2D vector transformation the z component is omitted):

(x, y, z) \rightarrow (x'/w, y'/w, z'/w)

where

(x', y', z', w') = mat * \begin{bmatrix} x & y & z & 1 \end
{bmatrix}

and

w = \fork{w'}{if $w' \ne 0$}{\infty}{otherwise}

Note that the function transforms a sparse set of 2D or 3D vectors. If you want
to transform an image using perspective transformation, use warpPerspective() .
If you have an inverse task, i.e. want to compute the most probable perspective
transformation out of several pairs of corresponding points, you can use
getPerspectiveTransform() or findHomography() .

See also: transform() , warpPerspective() , getPerspectiveTransform() ,
findHomography()

===========================================================================
*cv-phase*

void phase(const Mat& x, const Mat& y, Mat& angle, bool angleInDegrees=false)~

    Calculates the rotation angle of 2d vectors

                  • x – The source floating-point array of x-coordinates of 2D
                    vectors
                  • y – The source array of y-coordinates of 2D vectors; must
                    have the same size and the same type as x
    Parameters:   • angle – The destination array of vector angles; it will
                    have the same size and same type as x
                  • angleInDegrees – When it is true, the function will compute
                    angle in degrees, otherwise they will be measured in
                    radians

The function phase computes the rotation angle of each 2D vector that is formed
from the corresponding elements of x and y :

angle (I) = atan2 ( y (I), x (I))

The angle estimation accuracy is \sim\,0.3^\circ , when x(I)=y(I)=0 , the
corresponding angle (I) is set to 0 .

See also:

===========================================================================
*cv-polarToCart*

void polarToCart(const Mat& magnitude, const Mat& angle, Mat& x, Mat& y, bool
    angleInDegrees=false)~

    Computes x and y coordinates of 2D vectors from their magnitude and angle.

                  • magnitude – The source floating-point array of magnitudes
                    of 2D vectors. It can be an empty matrix ( =Mat() ) - in
                    this case the function assumes that all the magnitudes are
                    =1. If it’s not empty, it must have the same size and same
                    type as angle
                  • angle – The source floating-point array of angles of the 2D
    Parameters:     vectors
                  • x – The destination array of x-coordinates of 2D vectors;
                    will have the same size and the same type as angle
                  • y – The destination array of y-coordinates of 2D vectors;
                    will have the same size and the same type as angle
                  • angleInDegrees – When it is true, the input angles are
                    measured in degrees, otherwise they are measured in radians

The function polarToCart computes the cartesian coordinates of each 2D vector
represented by the corresponding elements of magnitude and angle :

\begin{array}{l} x (I) = magnitude (I) \cos ( angle
(I)) \\ y (I) = magnitude (I) \sin ( angle (I)) \\ \
end{array}

The relative accuracy of the estimated coordinates is \sim\,10^{-6} .

See also: cartToPolar() , magnitude() , phase() , exp() , log() , pow() , sqrt
()

===========================================================================
*cv-pow*

void pow(const Mat& src, double p, Mat& dst)~

void pow(const MatND& src, double p, MatND& dst)

    Raises every array element to a power.

                  • src – The source array
    Parameters:   • p – The exponent of power
                  • dst – The destination array; will have the same size and
                    the same type as src

The function pow raises every element of the input array to p :

dst (I) = \fork{src(I)^p}{if p is integer}{|\texttt
{src}(I)|^p}{otherwise}

That is, for a non-integer power exponent the absolute values of input array
elements are used. However, it is possible to get true values for negative
values using some extra operations, as the following example, computing the 5th
root of array src , shows:

Mat mask = src < 0;
pow(src, 1./5, dst);
subtract(Scalar::all(0), dst, dst, mask);

For some values of p , such as integer values, 0.5, and -0.5, specialized
faster algorithms are used.

See also: sqrt() , exp() , log() , cartToPolar() , polarToCart()

===========================================================================
*cv-RNG*

Random number generator class.

class CV_EXPORTS RNG
{
public:
    enum { A=4164903690U, UNIFORM=0, NORMAL=1 };

    // constructors
    RNG();
    RNG(uint64 state);

    // returns 32-bit unsigned random number
    unsigned next();

    // return random numbers of the specified type
    operator uchar();
    operator schar();
    operator ushort();
    operator short();
    operator unsigned();
        // returns a random integer sampled uniformly from [0, N).
        unsigned operator()(unsigned N);
        unsigned operator()();
    operator int();
    operator float();
    operator double();
    // returns a random number sampled uniformly from [a, b) range
    int uniform(int a, int b);
    float uniform(float a, float b);
    double uniform(double a, double b);

    // returns Gaussian random number with zero mean.
        double gaussian(double sigma);

    // fills array with random numbers sampled from the specified distribution
    void fill( Mat& mat, int distType, const Scalar& a, const Scalar& b );
    void fill( MatND& mat, int distType, const Scalar& a, const Scalar& b );

    // internal state of the RNG (could change in the future)
    uint64 state;
};

The class RNG implements random number generator. It encapsulates the RNG state
(currently, a 64-bit integer) and has methods to return scalar random values
and to fill arrays with random values. Currently it supports uniform and
Gaussian (normal) distributions. The generator uses Multiply-With-Carry
algorithm, introduced by G. Marsaglia ( http://en.wikipedia.org/wiki/
Multiply-with-carry ). Gaussian-distribution random numbers are generated using
Ziggurat algorithm ( http://en.wikipedia.org/wiki/Ziggurat_algorithm ),
introduced by G. Marsaglia and W. W. Tsang.

===========================================================================
*cv-RNG::RNG*

RNG::RNG()~

RNG::RNG(uint64 state)

    RNG constructors

    Parameter: state – the 64-bit value used to initialize the RNG

These are the RNG constructors. The first form sets the state to some
pre-defined value, equal to 2**32-1 in the current implementation. The second
form sets the state to the specified value. If the user passed state=0 , the
constructor uses the above default value instead, to avoid the singular random
number sequence, consisting of all zeros.

===========================================================================
*cv-RNG::next*

unsigned RNG::next()¶
    Returns the next random number

The method updates the state using MWC algorithm and returns the next 32-bit
random number.

cv::RNG::operator T~

RNG::operator uchar() RNG::operator schar() RNG::operator ushort()
    RNG::operator short() RNG::operator unsigned() RNG::operator int()
    RNG::operator float() RNG::operator double()¶
    Returns the next random number of the specified type

Each of the methods updates the state using MWC algorithm and returns the next
random number of the specified type. In the case of integer types the returned
number is from the whole available value range for the specified type. In the
case of floating-point types the returned value is from [0,1) range.

cv::RNG::operator ()~

unsigned RNG::operator()()~

unsigned RNG::operator()(unsigned N)

    Returns the next random number

    Parameter: N – The upper non-inclusive boundary of the returned random
               number

The methods transforms the state using MWC algorithm and returns the next
random number. The first form is equivalent to RNG::next() , the second form
returns the random number modulo N , i.e. the result will be in the range [0,
N) .

===========================================================================
*cv-RNG::uniform*

int RNG::uniform(int a, int b)~

float RNG::uniform(float a, float b)

double RNG::uniform(double a, double b)

    Returns the next random number sampled from the uniform distribution

                  • a – The lower inclusive boundary of the returned random
    Parameters:     numbers
                  • b – The upper non-inclusive boundary of the returned random
                    numbers

The methods transforms the state using MWC algorithm and returns the next
uniformly-distributed random number of the specified type, deduced from the
input parameter type, from the range [a, b) . There is one nuance, illustrated
by the following sample:

cv::RNG rng;

// will always produce 0
double a = rng.uniform(0, 1);

// will produce double from [0, 1)
double a1 = rng.uniform((double)0, (double)1);

// will produce float from [0, 1)
double b = rng.uniform(0.f, 1.f);

// will produce double from [0, 1)
double c = rng.uniform(0., 1.);

// will likely cause compiler error because of ambiguity:
//  RNG::uniform(0, (int)0.999999)? or RNG::uniform((double)0, 0.99999)?
double d = rng.uniform(0, 0.999999);

That is, the compiler does not take into account type of the variable that you
assign the result of RNG::uniform to, the only thing that matters to it is the
type of a and b parameters. So if you want a floating-point random number, but
the range boundaries are integer numbers, either put dots in the end, if they
are constants, or use explicit type cast operators, as in a1 initialization
above.

===========================================================================
*cv-RNG::gaussian*

double RNG::gaussian(double sigma)~

    Returns the next random number sampled from the Gaussian distribution

    Parameter: sigma – The standard deviation of the distribution

The methods transforms the state using MWC algorithm and returns the next
random number from the Gaussian distribution N(0,sigma) . That is, the mean
value of the returned random numbers will be zero and the standard deviation
will be the specified sigma .

===========================================================================
*cv-RNG::fill*

void RNG::fill(Mat& mat, int distType, const Scalar& a, const Scalar& b)~

void RNG::fill(MatND& mat, int distType, const Scalar& a, const Scalar& b)

    Fill arrays with random numbers

                  • mat – 2D or N-dimensional matrix. Currently matrices with
                    more than 4 channels are not supported by the methods. Use
                    reshape() as a possible workaround.
                  • distType – The distribution type, RNG::UNIFORM or
                    RNG::NORMAL
    Parameters:   • a – The first distribution parameter. In the case of
                    uniform distribution this is inclusive lower boundary. In
                    the case of normal distribution this is mean value.
                  • b – The second distribution parameter. In the case of
                    uniform distribution this is non-inclusive upper boundary.
                    In the case of normal distribution this is standard
                    deviation.

Each of the methods fills the matrix with the random values from the specified
distribution. As the new numbers are generated, the RNG state is updated
accordingly. In the case of multiple-channel images every channel is filled
independently, i.e. RNG can not generate samples from multi-dimensional
Gaussian distribution with non-diagonal covariation matrix directly. To do
that, first, generate matrix from the distribution N(0, I_n) , i.e. Gaussian
distribution with zero mean and identity covariation matrix, and then transform
it using transform() and the specific covariation matrix.

===========================================================================
*cv-randu*

template<typename _Tp> _Tp randu()~

void randu(Mat& mtx, const Scalar& low, const Scalar& high)

    Generates a single uniformly-distributed random number or array of random
    numbers

                  • mtx – The output array of random numbers. The array must be
                    pre-allocated and have 1 to 4 channels
    Parameters:   • low – The inclusive lower boundary of the generated random
                    numbers
                  • high – The exclusive upper boundary of the generated random
                    numbers

The template functions randu generate and return the next uniformly-distributed
random value of the specified type. randu<int>() is equivalent to (int)theRNG
(); etc. See RNG() description.

The second non-template variant of the function fills the matrix mtx with
uniformly-distributed random numbers from the specified range:

low _c \leq mtx (I)_c < high _c

See also: RNG() , randn() , theRNG() .

===========================================================================
*cv-randn*

void randn(Mat& mtx, const Scalar& mean, const Scalar& stddev)~

    Fills array with normally distributed random numbers

                  • mtx – The output array of random numbers. The array must be
                    pre-allocated and have 1 to 4 channels
    Parameters:   • mean – The mean value (expectation) of the generated random
                    numbers
                  • stddev – The standard deviation of the generated random
                    numbers

The function randn fills the matrix mtx with normally distributed random
numbers with the specified mean and standard deviation. is applied to the
generated numbers (i.e. the values are clipped)

See also: RNG() , randu()

===========================================================================
*cv-randShuffle*

void randShuffle(Mat& mtx, double iterFactor=1., RNG* rng=0)~

    Shuffles the array elements randomly

                  • mtx – The input/output numerical 1D array
                  • iterFactor – The scale factor that determines the number of
    Parameters:     random swap operations. See the discussion
                  • rng – The optional random number generator used for
                    shuffling. If it is zero, theRNG() () is used instead

The function randShuffle shuffles the specified 1D array by randomly choosing
pairs of elements and swapping them. The number of such swap operations will be
mtx.rows*mtx.cols*iterFactor See also: RNG() , sort()

===========================================================================
*cv-reduce*

void reduce(const Mat& mtx, Mat& vec, int dim, int reduceOp, int dtype=-1)~

    Reduces a matrix to a vector

                  • mtx – The source 2D matrix
                  • vec – The destination vector. Its size and type is defined
                    by dim and dtype parameters
                  • dim – The dimension index along which the matrix is
                    reduced. 0 means that the matrix is reduced to a single row
                    and 1 means that the matrix is reduced to a single column
                  • reduceOp –

                    The reduction operation, one of:

    Parameters:       □ CV_REDUCE_SUM The output is the sum of all of the
                        matrix’s rows/columns.
                      □ CV_REDUCE_AVG The output is the mean vector of all of
                        the matrix’s rows/columns.
                      □ CV_REDUCE_MAX The output is the maximum (column/
                        row-wise) of all of the matrix’s rows/columns.
                      □ CV_REDUCE_MIN The output is the minimum (column/
                        row-wise) of all of the matrix’s rows/columns.
                  • dtype – When it is negative, the destination vector will
                    have the same type as the source matrix, otherwise, its
                    type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), mtx.channels
                    ())

The function reduce reduces matrix to a vector by treating the matrix rows/
columns as a set of 1D vectors and performing the specified operation on the
vectors until a single row/column is obtained. For example, the function can be
used to compute horizontal and vertical projections of an raster image. In the
case of CV_REDUCE_SUM and CV_REDUCE_AVG the output may have a larger element
bit-depth to preserve accuracy. And multi-channel arrays are also supported in
these two reduction modes.

See also: repeat()

===========================================================================
*cv-repeat*

void repeat(const Mat& src, int ny, int nx, Mat& dst)~

Mat repeat(const Mat& src, int ny, int nx)

    Fill the destination array with repeated copies of the source array.

                  • src – The source array to replicate
                  • dst – The destination array; will have the same type as src
    Parameters:   • ny – How many times the src is repeated along the vertical
                    axis
                  • nx – How many times the src is repeated along the
                    horizontal axis

The functions repeat() duplicate the source array one or more times along each
of the two axes:

dst _{ij}= src _{i \mod src.rows , \; j \mod \texttt
{src.cols} }

The second variant of the function is more convenient to use with Matrix
Expressions See also: reduce() , Matrix Expressions

===========================================================================
*cv-saturate_cast*

template<typename _Tp> inline _Tp saturate_cast(unsigned char v)~

template<typename _Tp> inline _Tp saturate_cast(signed char v)

template<typename _Tp> inline _Tp saturate_cast(unsigned short v)

template<typename _Tp> inline _Tp saturate_cast(signed short v)

template<typename _Tp> inline _Tp saturate_cast(int v)

template<typename _Tp> inline _Tp saturate_cast(unsigned int v)

template<typename _Tp> inline _Tp saturate_cast(float v)

template<typename _Tp> inline _Tp saturate_cast(double v)

    Template function for accurate conversion from one primitive type to
    another

    Parameter: v – The function parameter

The functions saturate_cast resembles the standard C++ cast operations, such as
static_cast<T>() etc. They perform an efficient and accurate conversion from
one primitive type to another, see the introduction. “saturate” in the name
means that when the input value v is out of range of the target type, the
result will not be formed just by taking low bits of the input, but instead the
value will be clipped. For example:

uchar a = saturate_cast<uchar>(-100); // a = 0 (UCHAR_MIN)
short b = saturate_cast<short>(33333.33333); // b = 32767 (SHRT_MAX)

Such clipping is done when the target type is unsigned char, signed char,
unsigned short or signed short - for 32-bit integers no clipping is done.

When the parameter is floating-point value and the target type is an integer
(8-, 16- or 32-bit), the floating-point value is first rounded to the nearest
integer and then clipped if needed (when the target type is 8- or 16-bit).

This operation is used in most simple or complex image processing functions in
OpenCV.

See also: add() , subtract() , multiply() , divide() , Mat::convertTo()

===========================================================================
*cv-scaleAdd*

void scaleAdd(const Mat& src1, double scale, const Mat& src2, Mat& dst)~

void scaleAdd(const MatND& src1, double scale, const MatND& src2, MatND& dst)

    Calculates the sum of a scaled array and another array.

                  • src1 – The first source array
                  • scale – Scale factor for the first array
    Parameters:   • src2 – The second source array; must have the same size and
                    the same type as src1
                  • dst – The destination array; will have the same size and
                    the same type as src1

The function cvScaleAdd is one of the classical primitive linear algebra
operations, known as DAXPY or SAXPY in BLAS . It calculates the sum of a scaled
array and another array:

dst (I)= scale * src1 (I) + src2 (I)

The function can also be emulated with a matrix expression, for example:

Mat A(3, 3, CV_64F);
...
A.row(0) = A.row(1)*2 + A.row(2);

See also: add() , addWeighted() , subtract() , Mat::dot() , Mat::convertTo() ,
Matrix Expressions

===========================================================================
*cv-setIdentity*

void setIdentity(Mat& dst, const Scalar& value=Scalar(1))~

    Initializes a scaled identity matrix

    Parameters:   • dst – The matrix to initialize (not necessarily square)
                  • value – The value to assign to the diagonal elements

The function setIdentity() initializes a scaled identity matrix:

dst (i,j)= \fork{value}{ if $i=j$}{0}{otherwise}

The function can also be emulated using the matrix initializers and the matrix
expressions:

Mat A = Mat::eye(4, 3, CV_32F)*5;
// A will be set to [[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]]

See also: Mat::zeros() , Mat::ones() , Matrix Expressions , Mat::setTo() ,
Mat::operator=() ,

===========================================================================
*cv-solve*

bool solve(const Mat& src1, const Mat& src2, Mat& dst, int flags=DECOMP_LU)~

    Solves one or more linear systems or least-squares problems.

                  • src1 – The input matrix on the left-hand side of the system
                  • src2 – The input matrix on the right-hand side of the
                    system
                  • dst – The output solution
                  • flags –

                    The solution (matrix inversion) method

                      □ DECOMP_LU Gaussian elimination with optimal pivot
                        element chosen
                      □ DECOMP_CHOLESKY Cholesky LL^T factorization; the matrix
                        src1 must be symmetrical and positively defined
    Parameters:       □ DECOMP_EIG Eigenvalue decomposition; the matrix src1
                        must be symmetrical
                      □ DECOMP_SVD Singular value decomposition (SVD) method;
                        the system can be over-defined and/or the matrix src1
                        can be singular
                      □ DECOMP_QR QR factorization; the system can be
                        over-defined and/or the matrix src1 can be singular
                      □ DECOMP_NORMAL While all the previous flags are mutually
                        exclusive, this flag can be used together with any of
                        the previous. It means that the normal equations \
                        texttt{src1}^T*src1*dst=\
                        texttt{src1}^Tsrc2 are solved instead of the
                        original system src1*dst=\texttt
                        {src2}

The function solve solves a linear system or least-squares problem (the latter
is possible with SVD or QR methods, or by specifying the flag DECOMP_NORMAL ):

dst = \arg \min _X \| src1 * X - src2 \
|

If DECOMP_LU or DECOMP_CHOLESKY method is used, the function returns 1 if src1
(or src1^Tsrc1 ) is non-singular and 0 otherwise; in the
latter case dst is not valid. Other methods find some pseudo-solution in the
case of singular left-hand side part.

Note that if you want to find unity-norm solution of an under-defined singular
system src1*dst=0 , the function solve will not do the
work. Use SVD::solveZ() instead.

See also: invert() , SVD() , eigen()

===========================================================================
*cv-solveCubic*

void solveCubic(const Mat& coeffs, Mat& roots)~

    Finds the real roots of a cubic equation.

                  • coeffs – The equation coefficients, an array of 3 or 4
    Parameters:     elements
                  • roots – The destination array of real roots which will have
                    1 or 3 elements

The function solveCubic finds the real roots of a cubic equation:

(if coeffs is a 4-element vector)

coeffs [0] x^3 + coeffs [1] x^2 + coeffs [2] x + \
texttt{coeffs} [3] = 0

or (if coeffs is 3-element vector):

x^3 + coeffs [0] x^2 + coeffs [1] x + coeffs [2] = 0

The roots are stored to roots array.

===========================================================================
*cv-solvePoly*

void solvePoly(const Mat& coeffs, Mat& roots, int maxIters=20, int fig=100)~

    Finds the real or complex roots of a polynomial equation

                  • coeffs – The array of polynomial coefficients
                  • roots – The destination (complex) array of roots
    Parameters:   • maxIters – The maximum number of iterations the algorithm
                    does
                  • fig –

The function solvePoly finds real and complex roots of a polynomial equation:

coeffs [0] x^{n} + coeffs [1] x^{n-1} + ... + coeffs
[n-1] x + coeffs [n] = 0

===========================================================================
*cv-sort*

void sort(const Mat& src, Mat& dst, int flags)~

    Sorts each row or each column of a matrix

                  • src – The source single-channel array
                  • dst – The destination array of the same size and the same
                    type as src
                  • flags –

                    The operation flags, a combination of the following values:

                      □ CV_SORT_EVERY_ROW Each matrix row is sorted
    Parameters:         independently
                      □ CV_SORT_EVERY_COLUMN Each matrix column is sorted
                        independently. This flag and the previous one are
                        mutually exclusive
                      □ CV_SORT_ASCENDING Each matrix row is sorted in the
                        ascending order
                      □ CV_SORT_DESCENDING Each matrix row is sorted in the
                        descending order. This flag and the previous one are
                        also mutually exclusive

The function sort sorts each matrix row or each matrix column in ascending or
descending order. If you want to sort matrix rows or columns lexicographically,
you can use STL std::sort generic function with the proper comparison
predicate.

See also: sortIdx() , randShuffle()

===========================================================================
*cv-sortIdx*

void sortIdx(const Mat& src, Mat& dst, int flags)~

    Sorts each row or each column of a matrix

                  • src – The source single-channel array
                  • dst – The destination integer array of the same size as src
                  • flags –

                    The operation flags, a combination of the following values:

                      □ CV_SORT_EVERY_ROW Each matrix row is sorted
    Parameters:         independently
                      □ CV_SORT_EVERY_COLUMN Each matrix column is sorted
                        independently. This flag and the previous one are
                        mutually exclusive
                      □ CV_SORT_ASCENDING Each matrix row is sorted in the
                        ascending order
                      □ CV_SORT_DESCENDING Each matrix row is sorted in the
                        descending order. This flag and the previous one are
                        also mutually exclusive

The function sortIdx sorts each matrix row or each matrix column in ascending
or descending order. Instead of reordering the elements themselves, it stores
the indices of sorted elements in the destination array. For example:

Mat A = Mat::eye(3,3,CV_32F), B;
sortIdx(A, B, CV_SORT_EVERY_ROW + CV_SORT_ASCENDING);
// B will probably contain
// (because of equal elements in A some permutations are possible):
// [[1, 2, 0], [0, 2, 1], [0, 1, 2]]

See also: sort() , randShuffle()

===========================================================================
*cv-split*

void split(const Mat& mtx, Mat* mv)~

void split(const Mat& mtx, vector<Mat>& mv)

void split(const MatND& mtx, MatND* mv)

void split(const MatND& mtx, vector<MatND>& mv)

    Divides multi-channel array into several single-channel arrays

                  • mtx – The source multi-channel array
    Parameters:   • mv – The destination array or vector of arrays; The number
                    of arrays must match mtx.channels() . The arrays themselves
                    will be reallocated if needed

The functions split split multi-channel array into separate single-channel
arrays:

mv [c](I) = mtx (I)_c

If you need to extract a single-channel or do some other sophisticated channel
permutation, use mixChannels() See also: merge() , mixChannels() , cvtColor()

===========================================================================
*cv-sqrt*

void sqrt(const Mat& src, Mat& dst)~

void sqrt(const MatND& src, MatND& dst)

    Calculates square root of array elements

                  • src – The source floating-point array
    Parameters:   • dst – The destination array; will have the same size and
                    the same type as src

The functions sqrt calculate square root of each source array element. in the
case of multi-channel arrays each channel is processed independently. The
function accuracy is approximately the same as of the built-in std::sqrt .

See also: pow() , magnitude()

===========================================================================
*cv-subtract*

void subtract(const Mat& src1, const Mat& src2, Mat& dst)~

void subtract(const Mat& src1, const Mat& src2, Mat& dst, const Mat& mask)

void subtract(const Mat& src1, const Scalar& sc, Mat& dst, const Mat& mask=Mat
    ())

void subtract(const Scalar& sc, const Mat& src2, Mat& dst, const Mat& mask=Mat
    ())

void subtract(const MatND& src1, const MatND& src2, MatND& dst)

void subtract(const MatND& src1, const MatND& src2, MatND& dst, const MatND&
    mask)

void subtract(const MatND& src1, const Scalar& sc, MatND& dst, const MatND&
    mask=MatND())

void subtract(const Scalar& sc, const MatND& src2, MatND& dst, const MatND&
    mask=MatND())

    Calculates per-element difference between two arrays or array and a scalar

                  • src1 – The first source array
                  • src2 – The second source array. It must have the same size
                    and same type as src1
                  • sc – Scalar; the first or the second input parameter
    Parameters:   • dst – The destination array; it will have the same size and
                    same type as src1 ; see Mat::create
                  • mask – The optional operation mask, 8-bit single channel
                    array; specifies elements of the destination array to be
                    changed

The functions subtract compute

  • the difference between two arrays

    dst (I) = saturate ( src1 (I) - src2
    (I)) \quad if mask (I) \ne0

  • the difference between array and a scalar:

    dst (I) = saturate ( src1 (I) - sc ) \
    quad if mask (I) \ne0

  • the difference between scalar and an array:

    dst (I) = saturate ( sc - src2 (I)) \
    quad if mask (I) \ne0

where I is multi-dimensional index of array elements.

The first function in the above list can be replaced with matrix expressions:

dst = src1 - src2;
dst -= src2; // equivalent to subtract(dst, src2, dst);

See also: add() , addWeighted() , scaleAdd() , convertScale() , Matrix
Expressions , .

===========================================================================
*cv-SVD*

===========================================================================


Class for computing Singular Value Decomposition

class SVD
{
public:
    enum { MODIFY_A=1, NO_UV=2, FULL_UV=4 };
    // default empty constructor
    SVD();
    // decomposes A into u, w and vt: A = u*w*vt;
    // u and vt are orthogonal, w is diagonal
    SVD( const Mat& A, int flags=0 );
    // decomposes A into u, w and vt.
    SVD& operator ()( const Mat& A, int flags=0 );

    // finds such vector x, norm(x)=1, so that A*x = 0,
    // where A is singular matrix
    static void solveZ( const Mat& A, Mat& x );
    // does back-subsitution:
    // x = vt.t()*inv(w)*u.t()*rhs ~ inv(A)*rhs
    void backSubst( const Mat& rhs, Mat& x ) const;

    Mat u; // the left orthogonal matrix
    Mat w; // vector of singular values
    Mat vt; // the right orthogonal matrix
};

The class SVD is used to compute Singular Value Decomposition of a
floating-point matrix and then use it to solve least-square problems,
under-determined linear systems, invert matrices, compute condition numbers
etc. For a bit faster operation you can pass flags=SVD::MODIFY_A|... to modify
the decomposed matrix when it is not necessarily to preserve it. If you want to
compute condition number of a matrix or absolute value of its determinant - you
do not need u and vt , so you can pass flags=SVD::NO_UV|... . Another flag
FULL_UV indicates that full-size u and vt must be computed, which is not
necessary most of the time.

See also: invert() , solve() , eigen() , determinant()

===========================================================================
*cv-SVD::SVD*

SVD::SVD()~

SVD::SVD(const Mat& A, int flags=0)

    SVD constructors

                  • A – The decomposed matrix
                  • flags –

                    Operation flags

                      □ SVD::MODIFY_A The algorithm can modify the decomposed
                        matrix. It can save some space and speed-up processing
    Parameters:         a bit
                      □ SVD::NO_UV Indicates that only the vector of singular
                        values w is to be computed, while u and vt will be set
                        to empty matrices
                      □ SVD::FULL_UV When the matrix is not square, by default
                        the algorithm produces u and vt matrices of
                        sufficiently large size for the further A
                        reconstruction. If, however, FULL_UV flag is specified,
                        u and vt will be full-size square orthogonal matrices.

The first constructor initializes empty SVD structure. The second constructor
initializes empty SVD structure and then calls SVD::operator () .

cv::SVD::operator ()~

SVD& SVD::operator()( const Mat& A, int flags=0)~

    Performs SVD of a matrix

                  • A – The decomposed matrix
                  • flags –

                    Operation flags

                      □ SVD::MODIFY_A The algorithm can modify the decomposed
                        matrix. It can save some space and speed-up processing
    Parameters:         a bit
                      □ SVD::NO_UV Only singular values are needed. The
                        algorithm will not compute u and vt matrices
                      □ SVD::FULL_UV When the matrix is not square, by default
                        the algorithm produces u and vt matrices of
                        sufficiently large size for the further A
                        reconstruction. If, however, FULL_UV flag is specified,
                        u and vt will be full-size square orthogonal matrices.

The operator performs singular value decomposition of the supplied matrix. The
u , vt and the vector of singular values w are stored in the structure. The
same SVD structure can be reused many times with different matrices. Each time,
if needed, the previous u , vt and w are reclaimed and the new matrices are
created, which is all handled by Mat::create() .

===========================================================================
*cv-SVD::solveZ*

static void SVD::solveZ(const Mat& A, Mat& x)~

    Solves under-determined singular linear system

    Parameters:   • A – The left-hand-side matrix.
                  • x – The found solution

The method finds unit-length solution x of the under-determined system A x = 0
. Theory says that such system has infinite number of solutions, so the
algorithm finds the unit-length solution as the right singular vector
corresponding to the smallest singular value (which should be 0). In practice,
because of round errors and limited floating-point accuracy, the input matrix
can appear to be close-to-singular rather than just singular. So, strictly
speaking, the algorithm solves the following problem:

x^* = \arg \min _{x: \| x \| =1} \| A * x \|

===========================================================================
*cv-SVD::backSubst*

void SVD::backSubst(const Mat& rhs, Mat& x) const~

    Performs singular value back substitution

                  • rhs – The right-hand side of a linear system A \
    Parameters:     texttt{x} = rhs being solved, where A is the
                    matrix passed to SVD::SVD() or SVD::operator ()
                  • x – The found solution of the system

The method computes back substitution for the specified right-hand side:

x = vt ^T * diag( w )^{-1} * u ^T \
cdot rhs \sim A ^{-1} * rhs

Using this technique you can either get a very accurate solution of convenient
linear system, or the best (in the least-squares terms) pseudo-solution of an
overdetermined linear system. Note that explicit SVD with the further back
substitution only makes sense if you need to solve many linear systems with the
same left-hand side (e.g. A ). If all you need is to solve a single system
(possibly with multiple rhs immediately available), simply call solve() add
pass cv::DECOMP_SVD there - it will do absolutely the same thing.

===========================================================================
*cv-sum*

Scalar sum(const Mat& mtx)~

Scalar sum(const MatND& mtx)

    Calculates sum of array elements

    Parameter: mtx – The source array; must have 1 to 4 channels

The functions sum calculate and return the sum of array elements, independently
for each channel.

See also: countNonZero() , mean() , meanStdDev() , norm() , minMaxLoc() ,
reduce()

===========================================================================
*cv-theRNG*

RNG& theRNG()¶
    Returns the default random number generator

The function theRNG returns the default random number generator. For each
thread there is separate random number generator, so you can use the function
safely in multi-thread environments. If you just need to get a single random
number using this generator or initialize an array, you can use randu() or
randn() instead. But if you are going to generate many random numbers inside a
loop, it will be much faster to use this function to retrieve the generator and
then use RNG::operator _Tp() .

See also: RNG() , randu() , randn()

===========================================================================
*cv-trace*

Scalar trace(const Mat& mtx)~

    Returns the trace of a matrix

    Parameter: mtx – The source matrix

The function trace returns the sum of the diagonal elements of the matrix mtx .

tr ( mtx ) = \sum _i mtx (i,i)

===========================================================================
*cv-transform*

void transform(const Mat& src, Mat& dst, const Mat& mtx)~

    Performs matrix transformation of every array element.

                  • src – The source array; must have as many channels (1 to 4)
                    as mtx.cols or mtx.cols-1
    Parameters:   • dst – The destination array; will have the same size and
                    depth as src and as many channels as mtx.rows
                  • mtx – The transformation matrix

The function transform performs matrix transformation of every element of array
src and stores the results in dst :

dst (I) = mtx * src (I)

(when mtx.cols=src.channels() ), or

dst (I) = mtx * [ src (I); 1]

(when mtx.cols=src.channels()+1 )

That is, every element of an N -channel array src is considered as N -element
vector, which is transformed using a M \times N or M
\times N+1 matrix mtx into an element of M -channel array dst .

The function may be used for geometrical transformation of N -dimensional
points, arbitrary linear color space transformation (such as various kinds of
RGB \rightarrow YUV transforms), shuffling the image channels and so forth.

See also: perspectiveTransform() , getAffineTransform() ,
estimateRigidTransform() , warpAffine() , warpPerspective()

===========================================================================
*cv-transpose*

void transpose(const Mat& src, Mat& dst)~

    Transposes a matrix

    Parameters:   • src – The source array
                  • dst – The destination array of the same type as src

The function transpose() transposes the matrix src :

dst (i,j) = src (j,i)

Note that no complex conjugation is done in the case of a complex matrix, it
should be done separately if needed.

Help and Feedback

You did not find what you were looking for?

  • Try the Cheatsheet.
  • Ask a question in the user group/mailing list.
  • If you think something is missing or wrong in the documentation, please
    file a bug report.

Logo

Table Of Contents

  • Operations on Arrays
      □ cv::abs
      □ cv::absdiff
      □ cv::add
      □ cv::addWeighted
      □ bitwise_and
      □ bitwise_not
      □ bitwise_or
      □ bitwise_xor
      □ cv::calcCovarMatrix
      □ cv::cartToPolar
      □ cv::checkRange
      □ cv::compare
      □ cv::completeSymm
      □ cv::convertScaleAbs
      □ cv::countNonZero
      □ cv::cubeRoot
      □ cv::cvarrToMat
      □ cv::dct
      □ cv::dft
      □ cv::divide
      □ cv::determinant
      □ cv::eigen
      □ cv::exp
      □ cv::extractImageCOI
      □ cv::fastAtan2
      □ cv::flip
      □ cv::gemm
      □ cv::getConvertElem
      □ cv::getOptimalDFTSize
      □ cv::idct
      □ cv::idft
      □ cv::inRange
      □ cv::invert
      □ cv::log
      □ cv::LUT
      □ cv::magnitude
      □ cv::Mahalanobis
      □ cv::max
      □ cv::mean
      □ cv::meanStdDev
      □ cv::merge
      □ cv::min
      □ cv::minMaxLoc
      □ cv::mixChannels
      □ cv::mulSpectrums
      □ cv::multiply
      □ cv::mulTransposed
      □ cv::norm
      □ cv::normalize
      □ PCA
      □ cv::PCA::PCA
      □ cv::PCA::operator ()
      □ cv::PCA::project
      □ cv::PCA::backProject
      □ cv::perspectiveTransform
      □ cv::phase
      □ cv::polarToCart
      □ cv::pow
      □ RNG
      □ cv::RNG::RNG
      □ cv::RNG::next
      □ cv::RNG::operator T
      □ cv::RNG::operator ()
      □ cv::RNG::uniform
      □ cv::RNG::gaussian
      □ cv::RNG::fill
      □ cv::randu
      □ cv::randn
      □ cv::randShuffle
      □ cv::reduce
      □ cv::repeat
      □ saturate_cast
      □ cv::scaleAdd
      □ cv::setIdentity
      □ cv::solve
      □ cv::solveCubic
      □ cv::solvePoly
      □ cv::sort
      □ cv::sortIdx
      □ cv::split
      □ cv::sqrt
      □ cv::subtract
      □ SVD
      □ cv::SVD::SVD
      □ cv::SVD::operator ()
      □ cv::SVD::solveZ
      □ cv::SVD::backSubst
      □ cv::sum
      □ cv::theRNG
      □ cv::trace
      □ cv::transform
      □ cv::transpose

Previous topic

Basic Structures

Next topic

Dynamic Structures

This Page

  • Show Source

Quick search

[                  ] [Go] 
Enter search terms or a module, class or function name.

Navigation

  • index
  • next |
  • previous |
  • opencv v2.1 documentation »
  • core. The Core Functionality »

© Copyright 2010, authors. Created using Sphinx 0.6.2.
Navigation

  • index
  • next |
  • previous |
  • opencv v2.1 documentation »
  • core. The Core Functionality »

Dynamic Structures~

Help and Feedback

You did not find what you were looking for?

  • Try the Cheatsheet.
  • Ask a question in the user group/mailing list.
  • If you think something is missing or wrong in the documentation, please
    file a bug report.

Logo

Previous topic

Operations on Arrays

Next topic

Drawing Functions

This Page

  • Show Source

Quick search

[                  ] [Go] 
Enter search terms or a module, class or function name.

Navigation

  • index
  • next |
  • previous |
  • opencv v2.1 documentation »
  • core. The Core Functionality »

© Copyright 2010, authors. Created using Sphinx 0.6.2.
Navigation

  • index
  • next |
  • previous |
  • opencv v2.1 documentation »
  • core. The Core Functionality »

Drawing Functions~

Drawing functions work with matrices/images of arbitrary depth. The boundaries
of the shapes can be rendered with antialiasing (implemented only for 8-bit
images for now). All the functions include the parameter color that uses a rgb
value (that may be constructed with CV_RGB or the Scalar constructor ) for
color images and brightness for grayscale images. For color images the order
channel is normally Blue, Green, Red , this is what imshow() , imread() and
imwrite() expect , so if you form a color using Scalar constructor, it should
look like:

Scalar (blue \_ component, green \_ component, red \_ component[,
alpha \_ component])

If you are using your own image rendering and I/O functions, you can use any
channel ordering, the drawing functions process each channel independently and
do not depend on the channel order or even on the color space used. The whole
image can be converted from BGR to RGB or to a different color space using
cvtColor() .

If a drawn figure is partially or completely outside the image, the drawing
functions clip it. Also, many drawing functions can handle pixel coordinates
specified with sub-pixel accuracy, that is, the coordinates can be passed as
fixed-point numbers, encoded as integers. The number of fractional bits is
specified by the shift parameter and the real point coordinates are calculated
as Point(x,y)\rightarrowPoint2f(x*2^{-shift},y*2^{-shift}) .
This feature is especially effective wehn rendering antialiased shapes.

Also, note that the functions do not support alpha-transparency - when the
target image is 4-channnel, then the color[3] is simply copied to the repainted
pixels. Thus, if you want to paint semi-transparent shapes, you can paint them
in a separate buffer and then blend it with the main image.

===========================================================================
*cv-circle*

void circle(Mat& img, Point center, int radius, const Scalar& color, int
    thickness=1, int lineType=8, int shift=0)~

    Draws a circle

                  • img – Image where the circle is drawn
                  • center – Center of the circle
                  • radius – Radius of the circle
                  • color – Circle color
                  • thickness – Thickness of the circle outline if positive;
    Parameters:     negative thickness means that a filled circle is to be
                    drawn
                  • lineType – Type of the circle boundary, see line()
                    description
                  • shift – Number of fractional bits in the center coordinates
                    and radius value

The function circle draws a simple or filled circle with a given center and
radius.

===========================================================================
*cv-clipLine*

bool clipLine(Size imgSize, Point& pt1, Point& pt2)~

bool clipLine(Rect imgRect, Point& pt1, Point& pt2)

    Clips the line against the image rectangle

                  • imgSize – The image size; the image rectangle will be Rect
                    (0, 0, imgSize.width, imgSize.height)
    Parameters:   • imgSize – The image rectangle
                  • pt1 – The first line point
                  • pt2 – The second line point

The functions clipLine calculate a part of the line segment which is entirely
within the specified rectangle. They return false if the line segment is
completely outside the rectangle and true otherwise.

===========================================================================
*cv-ellipse*

void ellipse(Mat& img, Point center, Size axes, double angle, double startAngle
    , double endAngle, const Scalar& color, int thickness=1, int lineType=8,
    int shift=0)~

void ellipse(Mat& img, const RotatedRect& box, const Scalar& color, int
    thickness=1, int lineType=8)

    Draws a simple or thick elliptic arc or an fills ellipse sector.

                  • img – The image
                  • center – Center of the ellipse
                  • axes – Length of the ellipse axes
                  • angle – The ellipse rotation angle in degrees
                  • startAngle – Starting angle of the elliptic arc in degrees
                  • endAngle – Ending angle of the elliptic arc in degrees
                  • box – Alternative ellipse representation via a RotatedRect
                    , i.e. the function draws an ellipse inscribed in the
    Parameters:     rotated rectangle
                  • color – Ellipse color
                  • thickness – Thickness of the ellipse arc outline if
                    positive, otherwise this indicates that a filled ellipse
                    sector is to be drawn
                  • lineType – Type of the ellipse boundary, see line()
                    description
                  • shift – Number of fractional bits in the center coordinates
                    and axes’ values

The functions ellipse with less parameters draw an ellipse outline, a filled
ellipse, an elliptic arc or a filled ellipse sector. A piecewise-linear curve
is used to approximate the elliptic arc boundary. If you need more control of
the ellipse rendering, you can retrieve the curve using ellipse2Poly() and then
render it with polylines() or fill it with fillPoly() . If you use the first
variant of the function and want to draw the whole ellipse, not an arc, pass
startAngle=0 and endAngle=360 . The picture below explains the meaning of the
parameters.

Parameters of Elliptic Arc

_images/ellipse.png

===========================================================================
*cv-ellipse2Poly*

void ellipse2Poly(Point center, Size axes, int angle, int startAngle, int
    endAngle, int delta, vector<Point>& pts)~

    Approximates an elliptic arc with a polyline

                  • center – Center of the arc
                  • axes – Half-sizes of the arc. See ellipse()
                  • angle – Rotation angle of the ellipse in degrees. See
                    ellipse()
    Parameters:   • startAngle – Starting angle of the elliptic arc in degrees
                  • endAngle – Ending angle of the elliptic arc in degrees
                  • delta – Angle between the subsequent polyline vertices. It
                    defines the approximation accuracy.
                  • pts – The output vector of polyline vertices

The function ellipse2Poly computes the vertices of a polyline that approximates
the specified elliptic arc. It is used by ellipse() .

===========================================================================
*cv-fillConvexPoly*

void fillConvexPoly(Mat& img, const Point* pts, int npts, const Scalar& color,
    int lineType=8, int shift=0)~

    Fills a convex polygon.

                  • img – Image
                  • pts – The polygon vertices
                  • npts – The number of polygon vertices
    Parameters:   • color – Polygon color
                  • lineType – Type of the polygon boundaries, see line()
                    description
                  • shift – The number of fractional bits in the vertex
                    coordinates

The function fillConvexPoly draws a filled convex polygon. This function is
much faster than the function fillPoly and can fill not only convex polygons
but any monotonic polygon without self-intersections, i.e., a polygon whose
contour intersects every horizontal line (scan line) twice at the most (though,
its top-most and/or the bottom edge could be horizontal).

===========================================================================
*cv-fillPoly*

void fillPoly(Mat& img, const Point** pts, const int* npts, int ncontours,
    const Scalar& color, int lineType=8, int shift=0, Point offset=Point())~

    Fills the area bounded by one or more polygons

                  • img – Image
                  • pts – Array of polygons, each represented as an array of
                    points
                  • npts – The array of polygon vertex counters
                  • ncontours – The number of contours that bind the filled
    Parameters:     region
                  • color – Polygon color
                  • lineType – Type of the polygon boundaries, see line()
                    description
                  • shift – The number of fractional bits in the vertex
                    coordinates

The function fillPoly fills an area bounded by several polygonal contours. The
function can fills complex areas, for example, areas with holes, contours with
self-intersections (some of thier parts), and so forth.

===========================================================================
*cv-getTextSize*

Size getTextSize(const string& text, int fontFace, double fontScale, int
    thickness, int* baseLine)~

    Calculates the width and height of a text string.

                  • text – The input text string
                  • fontFace – The font to use; see putText()
                  • fontScale – The font scale; see putText()
    Parameters:   • thickness – The thickness of lines used to render the text;
                    see putText()
                  • baseLine – The output parameter - y-coordinate of the
                    baseline relative to the bottom-most text point

The function getTextSize calculates and returns size of the box that contain
the specified text. That is, the following code will render some text, the
tight box surrounding it and the baseline:

// Use "y" to show that the baseLine is about
string text = "Funny text inside the box";
int fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;
double fontScale = 2;
int thickness = 3;

Mat img(600, 800, CV_8UC3, Scalar::all(0));

int baseline=0;
Size textSize = getTextSize(text, fontFace,
                            fontScale, thickness, &baseline);
baseline += thickness;

// center the text
Point textOrg((img.cols - textSize.width)/2,
              (img.rows + textSize.height)/2);

// draw the box
rectangle(img, textOrg + Point(0, baseline),
          textOrg + Point(textSize.width, -textSize.height),
          Scalar(0,0,255));
// ... and the baseline first
line(img, textOrg + Point(0, thickness),
     textOrg + Point(textSize.width, thickness),
     Scalar(0, 0, 255));

// then put the text itself
putText(img, text, textOrg, fontFace, fontScale,
        Scalar::all(255), thickness, 8);

===========================================================================
*cv-line*

void line(Mat& img, Point pt1, Point pt2, const Scalar& color, int thickness=1,
    int lineType=8, int shift=0)~

    Draws a line segment connecting two points

                  • img – The image
                  • pt1 – First point of the line segment
                  • pt2 – Second point of the line segment
                  • color – Line color
                  • thickness – Line thickness
                  • lineType –
    Parameters:
                    Type of the line:

                      □ 8 (or omitted) 8-connected line.
                      □ 4 4-connected line.
                      □ CV_AA antialiased line.
                  • shift – Number of fractional bits in the point coordinates

The function line draws the line segment between pt1 and pt2 points in the
image. The line is clipped by the image boundaries. For non-antialiased lines
with integer coordinates the 8-connected or 4-connected Bresenham algorithm is
used. Thick lines are drawn with rounding endings. Antialiased lines are drawn
using Gaussian filtering. To specify the line color, the user may use the macro
CV_RGB(r, g, b) .

===========================================================================
*cv-LineIterator*

===========================================================================


Class for iterating pixels on a raster line

class LineIterator
{
public:
    // creates iterators for the line connecting pt1 and pt2
    // the line will be clipped on the image boundaries
    // the line is 8-connected or 4-connected
    // If leftToRight=true, then the iteration is always done
    // from the left-most point to the right most,
    // not to depend on the ordering of pt1 and pt2 parameters
    LineIterator(const Mat& img, Point pt1, Point pt2,
                 int connectivity=8, bool leftToRight=false);newline
    // returns pointer to the current line pixel
    uchar* operator *();newline
    // move the iterator to the next pixel
    LineIterator& operator ++();newline
    LineIterator operator ++(int);newline

    // internal state of the iterator
    uchar* ptr;newline
    int err, count;newline
    int minusDelta, plusDelta;newline
    int minusStep, plusStep;newline
};

The class LineIterator is used to get each pixel of a raster line. It can be
treated as versatile implementation of the Bresenham algorithm, where you can
stop at each pixel and do some extra processing, for example, grab pixel values
along the line, or draw a line with some effect (e.g. with XOR operation).

The number of pixels along the line is store in LineIterator::count .

// grabs pixels along the line (pt1, pt2)
// from 8-bit 3-channel image to the buffer
LineIterator it(img, pt1, pt2, 8);
vector<Vec3b> buf(it.count);

for(int i = 0; i < it.count; i++, ++it)
    buf[i] = *(const Vec3b)*it;

===========================================================================
*cv-rectangle*

void rectangle(Mat& img, Point pt1, Point pt2, const Scalar& color, int
    thickness=1, int lineType=8, int shift=0)~

    Draws a simple, thick, or filled up-right rectangle.

                  • img – Image
                  • pt1 – One of the rectangle’s vertices
                  • pt2 – Opposite to pt1 rectangle vertex
                  • color – Rectangle color or brightness (grayscale image)
    Parameters:   • thickness – Thickness of lines that make up the rectangle.
                    Negative values, e.g. CV_FILLED , mean that the function
                    has to draw a filled rectangle.
                  • lineType – Type of the line, see line() description
                  • shift – Number of fractional bits in the point coordinates

The function rectangle draws a rectangle outline or a filled rectangle, which
two opposite corners are pt1 and pt2 .

===========================================================================
*cv-polylines*

void polylines(Mat& img, const Point** pts, const int* npts, int ncontours,
    bool isClosed, const Scalar& color, int thickness=1, int lineType=8, int
    shift=0)~

    Draws several polygonal curves

                  • img – The image
                  • pts – Array of polygonal curves
                  • npts – Array of polygon vertex counters
                  • ncontours – The number of curves
                  • isClosed – Indicates whether the drawn polylines are closed
                    or not. If they are closed, the function draws the line
    Parameters:     from the last vertex of each curve to its first vertex
                  • color – Polyline color
                  • thickness – Thickness of the polyline edges
                  • lineType – Type of the line segments, see line()
                    description
                  • shift – The number of fractional bits in the vertex
                    coordinates

The function polylines draws one or more polygonal curves.

===========================================================================
*cv-putText*

void putText(Mat& img, const string& text, Point org, int fontFace, double
    fontScale, Scalar color, int thickness=1, int lineType=8, bool
    bottomLeftOrigin=false)~

    Draws a text string

                  • img – The image
                  • text – The text string to be drawn
                  • org – The bottom-left corner of the text string in the
                    image
                  • fontFace –

                    The font type, one of FONT_HERSHEY_SIMPLEX ,
                    FONT_HERSHEY_PLAIN , FONT_HERSHEY_DUPLEX ,
                    FONT_HERSHEY_COMPLEX , FONT_HERSHEY_TRIPLEX ,
                    FONT_HERSHEY_COMPLEX_SMALL , FONT_HERSHEY_SCRIPT_SIMPLEX or
                    FONT_HERSHEY_SCRIPT_COMPLEX ,
    Parameters:
                        where each of the font id’s can be combined with
                        FONT_HERSHEY_ITALIC to get the slanted letters.

                  • fontScale – The font scale factor that is multiplied by the
                    font-specific base size
                  • color – The text color
                  • thickness – Thickness of the lines used to draw the text
                  • lineType – The line type; see line for details
                  • bottomLeftOrigin – When true, the image data origin is at
                    the bottom-left corner, otherwise it’s at the top-left
                    corner

The function putText renders the specified text string in the image. Symbols
that can not be rendered using the specified font are replaced by question
marks. See getTextSize() for a text rendering code example.

Help and Feedback

You did not find what you were looking for?

  • Try the Cheatsheet.
  • Ask a question in the user group/mailing list.
  • If you think something is missing or wrong in the documentation, please
    file a bug report.

Logo

Table Of Contents

  • Drawing Functions
      □ cv::circle
      □ cv::clipLine
      □ cv::ellipse
      □ cv::ellipse2Poly
      □ cv::fillConvexPoly
      □ cv::fillPoly
      □ cv::getTextSize
      □ cv::line
      □ LineIterator
      □ cv::rectangle
      □ cv::polylines
      □ cv::putText

Previous topic

Dynamic Structures

Next topic

XML/YAML Persistence

This Page

  • Show Source

Quick search

[                  ] [Go] 
Enter search terms or a module, class or function name.

Navigation

  • index
  • next |
  • previous |
  • opencv v2.1 documentation »
  • core. The Core Functionality »

© Copyright 2010, authors. Created using Sphinx 0.6.2.
Navigation

  • index
  • next |
  • previous |
  • opencv v2.1 documentation »
  • core. The Core Functionality »

XML/YAML Persistence~

===========================================================================
*cv-FileStorage*

===========================================================================


The XML/YAML file storage class

class FileStorage
{
public:
    enum { READ=0, WRITE=1, APPEND=2 };
    enum { UNDEFINED=0, VALUE_EXPECTED=1, NAME_EXPECTED=2, INSIDE_MAP=4 };
    // the default constructor
    FileStorage();
    // the constructor that opens the file for reading
    // (flags=FileStorage::READ) or writing (flags=FileStorage::WRITE)
    FileStorage(const string& filename, int flags);
    // wraps the already opened CvFileStorage*
    FileStorage(CvFileStorage* fs);
    // the destructor; closes the file if needed
    virtual ~FileStorage();

    // opens the specified file for reading (flags=FileStorage::READ)
    // or writing (flags=FileStorage::WRITE)
    virtual bool open(const string& filename, int flags);
    // checks if the storage is opened
    virtual bool isOpened() const;
    // closes the file
    virtual void release();

    // returns the first top-level node
    FileNode getFirstTopLevelNode() const;
    // returns the root file node
    // (it's the parent of the first top-level node)
    FileNode root(int streamidx=0) const;
    // returns the top-level node by name
    FileNode operator[](const string& nodename) const;
    FileNode operator[](const char* nodename) const;

    // returns the underlying CvFileStorage*
    CvFileStorage* operator *() { return fs; }
    const CvFileStorage* operator *() const { return fs; }

    // writes the certain number of elements of the specified format
    // (see DataType) without any headers
    void writeRaw( const string& fmt, const uchar* vec, size_t len );

    // writes an old-style object (CvMat, CvMatND etc.)
    void writeObj( const string& name, const void* obj );

    // returns the default object name from the filename
    // (used by cvSave() with the default object name etc.)
    static string getDefaultObjectName(const string& filename);

    Ptr<CvFileStorage> fs;
    string elname;
    vector<char> structs;
    int state;
};

===========================================================================
*cv-FileNode*

===========================================================================


The XML/YAML file node class

class CV_EXPORTS FileNode
{
public:
    enum { NONE=0, INT=1, REAL=2, FLOAT=REAL, STR=3,
        STRING=STR, REF=4, SEQ=5, MAP=6, TYPE_MASK=7,
        FLOW=8, USER=16, EMPTY=32, NAMED=64 };
    FileNode();
    FileNode(const CvFileStorage* fs, const CvFileNode* node);
    FileNode(const FileNode& node);
    FileNode operator[](const string& nodename) const;
    FileNode operator[](const char* nodename) const;
    FileNode operator[](int i) const;
    int type() const;
    int rawDataSize(const string& fmt) const;
    bool empty() const;
    bool isNone() const;
    bool isSeq() const;
    bool isMap() const;
    bool isInt() const;
    bool isReal() const;
    bool isString() const;
    bool isNamed() const;
    string name() const;
    size_t size() const;
    operator int() const;
    operator float() const;
    operator double() const;
    operator string() const;

    FileNodeIterator begin() const;
    FileNodeIterator end() const;

    void readRaw( const string& fmt, uchar* vec, size_t len ) const;
    void* readObj() const;

    // do not use wrapper pointer classes for better efficiency
    const CvFileStorage* fs;
    const CvFileNode* node;
};

===========================================================================
*cv-FileNodeIterator*

===========================================================================


The XML/YAML file node iterator class

class CV_EXPORTS FileNodeIterator
{
public:
    FileNodeIterator();
    FileNodeIterator(const CvFileStorage* fs,
        const CvFileNode* node, size_t ofs=0);
    FileNodeIterator(const FileNodeIterator& it);
    FileNode operator *() const;
    FileNode operator ->() const;

    FileNodeIterator& operator ++();
    FileNodeIterator operator ++(int);
    FileNodeIterator& operator --();
    FileNodeIterator operator --(int);
    FileNodeIterator& operator += (int);
    FileNodeIterator& operator -= (int);

    FileNodeIterator& readRaw( const string& fmt, uchar* vec,
                               size_t maxCount=(size_t)INT_MAX );

    const CvFileStorage* fs;
    const CvFileNode* container;
    CvSeqReader reader;
    size_t remaining;
};

Help and Feedback

You did not find what you were looking for?

  • Try the Cheatsheet.
  • Ask a question in the user group/mailing list.
  • If you think something is missing or wrong in the documentation, please
    file a bug report.

Logo

Table Of Contents

  • XML/YAML Persistence
      □ FileStorage
      □ FileNode
      □ FileNodeIterator

Previous topic

Drawing Functions

Next topic

Clustering

This Page

  • Show Source

Quick search

[                  ] [Go] 
Enter search terms or a module, class or function name.

Navigation

  • index
  • next |
  • previous |
  • opencv v2.1 documentation »
  • core. The Core Functionality »

© Copyright 2010, authors. Created using Sphinx 0.6.2.
Navigation

  • index
  • next |
  • previous |
  • opencv v2.1 documentation »
  • core. The Core Functionality »

===========================================================================
*cv-Clustering2*

===========================================================================
*cv-kmeans*

double kmeans(const Mat& samples, int clusterCount, Mat& labels, TermCriteria
    termcrit, int attempts, int flags, Mat* centers)~

    Finds the centers of clusters and groups the input samples around the
    clusters.

                  • samples – Floating-point matrix of input samples, one row
                    per sample
                  • clusterCount – The number of clusters to split the set by
                  • labels – The input/output integer array that will store the
                    cluster indices for every sample
                  • termcrit – Specifies maximum number of iterations and/or
                    accuracy (distance the centers can move by between
                    subsequent iterations)
                  • attempts – How many times the algorithm is executed using
                    different initial labelings. The algorithm returns the
                    labels that yield the best compactness (see the last
                    function parameter)
                  • flags –

                    It can take the following values:
    Parameters:
                      □ KMEANS_RANDOM_CENTERS Random initial centers are
                        selected in each attempt
                      □ KMEANS_PP_CENTERS Use kmeans++ center initialization by
                        Arthur and Vassilvitskii
                      □ 
                        KMEANS_USE_INITIAL_LABELS During the first (and
                            possibly the only) attempt, the
                            function uses the user-supplied labels instaed of
                            computing them from the initial centers. For the
                            second and further attempts, the function will use
                            the random or semi-random centers (use one of
                            KMEANS_*_CENTERS flag to specify the exact method)

                  • centers – The output matrix of the cluster centers, one row
                    per each cluster center

The function kmeans implements a k-means algorithm that finds the centers of
clusterCount clusters and groups the input samples around the clusters. On
output, labels_i contains a 0-based cluster index for the sample
stored in the i^{th} row of the samples matrix.

The function returns the compactness measure, which is computed as

\sum _i \| samples _i - centers _{ labels _i} \| ^2

after every attempt; the best (minimum) value is chosen and the corresponding
labels and the compactness value are returned by the function. Basically, the
user can use only the core of the function, set the number of attempts to 1,
initialize labels each time using some custom algorithm and pass them with (
flags = KMEANS_USE_INITIAL_LABELS ) flag, and then choose the best
(most-compact) clustering.

===========================================================================
*cv-partition*

template<typename _Tp, class _EqPredicate> int()~

partition(const vector<_Tp>& vec, vector<int>& labels, _EqPredicate predicate=
    _EqPredicate())~

    Splits an element set into equivalency classes.

                  • vec – The set of elements stored as a vector
                  • labels – The output vector of labels; will contain as many
                    elements as vec . Each label labels[i] is 0-based cluster
                    index of vec[i]
    Parameters:   • predicate – The equivalence predicate (i.e. pointer to a
                    boolean function of two arguments or an instance of the
                    class that has the method bool operator()(const _Tp& a,
                    const _Tp& b) . The predicate returns true when the
                    elements are certainly if the same class, and false if they
                    may or may not be in the same class

The generic function partition implements an O(N^2) algorithm for splitting a
set of N elements into one or more equivalency classes, as described in http://
en.wikipedia.org/wiki/Disjoint-set_data_structure . The function returns the
number of equivalency classes.

Help and Feedback

You did not find what you were looking for?

  • Try the Cheatsheet.
  • Ask a question in the user group/mailing list.
  • If you think something is missing or wrong in the documentation, please
    file a bug report.

Logo

Table Of Contents

  • Clustering
      □ cv::kmeans
      □ cv::partition

Previous topic

XML/YAML Persistence

Next topic

Utility and System Functions and Macros

This Page

  • Show Source

Quick search

[                  ] [Go] 
Enter search terms or a module, class or function name.

Navigation

  • index
  • next |
  • previous |
  • opencv v2.1 documentation »
  • core. The Core Functionality »

© Copyright 2010, authors. Created using Sphinx 0.6.2.
Navigation

  • index
  • next |
  • previous |
  • opencv v2.1 documentation »
  • core. The Core Functionality »

Utility and System Functions and Macros~

===========================================================================
*cv-alignPtr*

template<typename _Tp> _Tp* alignPtr(_Tp* ptr, int n=sizeof(_Tp))~

    Aligns pointer to the specified number of bytes

    Parameters:   • ptr – The aligned pointer
                  • n – The alignment size; must be a power of two

The function returns the aligned pointer of the same type as the input pointer:

\texttt{(\_Tp*)(((size\_t)ptr + n-1) \& -n)}

===========================================================================
*cv-alignSize*

size_t alignSize(size_t sz, int n)~

    Aligns a buffer size to the specified number of bytes

    Parameters:   • sz – The buffer size to align
                  • n – The alignment size; must be a power of two

The function returns the minimum number that is greater or equal to sz and is
divisble by n :

\texttt{(sz + n-1) \& -n}

===========================================================================
*cv-allocate*

template<typename _Tp> _Tp* allocate(size_t n)~

    Allocates an array of elements

    Parameter: n – The number of elements to allocate

The generic function allocate allocates buffer for the specified number of
elements. For each element the default constructor is called.

===========================================================================
*cv-deallocate*

template<typename _Tp> void deallocate(_Tp* ptr, size_t n)~

    Allocates an array of elements

    Parameters:   • ptr – Pointer to the deallocated buffer
                  • n – The number of elements in the buffer

The generic function deallocate deallocates the buffer allocated with allocate
() . The number of elements must match the number passed to allocate() .

===========================================================================
*cv-CV_Assert*

CV_Assert(expr)¶
    Checks a condition at runtime.

#define CV_Assert( expr ) ...
#define CV_DbgAssert(expr) ...

    param expr: The checked expression

The macros CV_Assert and CV_DbgAssert evaluate the specified expression and if
it is 0, the macros raise an error (see error() ). The macro CV_Assert checks
the condition in both Debug and Release configurations, while CV_DbgAssert is
only retained in the Debug configuration.

===========================================================================
*cv-error*

void error(const Exception& exc)~

#define CV_Error( code, msg ) <...>

#define CV_Error_( code, args ) <...>

    Signals an error and raises the exception

                  • exc – The exception to throw
                  • code – The error code, normally, a negative value. The list
    Parameters:     of pre-defined error codes can be found in cxerror.h
                  • msg – Text of the error message
                  • args – printf-like formatted error message in parantheses

The function and the helper macros CV_Error and CV_Error_ call the error
handler. Currently, the error handler prints the error code ( exc.code ), the
context ( exc.file , exc.line and the error message exc.err to the standard
error stream stderr . In Debug configuration it then provokes memory access
violation, so that the execution stack and all the parameters can be analyzed
in debugger. In Release configuration the exception exc is thrown.

The macro CV_Error_ can be used to construct the error message on-fly to
include some dynamic information, for example:

// note the extra parentheses around the formatted text message
CV_Error_(CV_StsOutOfRange,
    ("the matrix element (
    i, j, mtx.at<float>(i,j)))

===========================================================================
*cv-Exception*

===========================================================================


The exception class passed to error

class  Exception
{
public:
    // various constructors and the copy operation
    Exception() { code = 0; line = 0; }
    Exception(int _code, const string& _err,
              const string& _func, const string& _file, int _line);newline
    Exception(const Exception& exc);newline
    Exception& operator = (const Exception& exc);newline

    // the error code
    int code;newline
    // the error text message
    string err;newline
    // function name where the error happened
    string func;newline
    // the source file name where the error happened
    string file;newline
    // the source file line where the error happened
    int line;
};

The class Exception encapsulates all or almost all the necessary information
about the error happened in the program. The exception is usually constructed
and thrown implicitly, via CV_Error and CV_Error_ macros, see error() .

===========================================================================
*cv-fastMalloc*

void* fastMalloc(size_t size)~

    Allocates aligned memory buffer

    Parameter: size – The allocated buffer size

The function allocates buffer of the specified size and returns it. When the
buffer size is 16 bytes or more, the returned buffer is aligned on 16 bytes.

===========================================================================
*cv-fastFree*

void fastFree(void* ptr)~

    Deallocates memory buffer

    Parameter: ptr – Pointer to the allocated buffer

The function deallocates the buffer, allocated with fastMalloc() . If NULL
pointer is passed, the function does nothing.

===========================================================================
*cv-format*

string format(const char* fmt, ...)~

    Returns a text string formatted using printf-like expression

    Parameter: fmt – The printf-compatible formatting specifiers

The function acts like sprintf , but forms and returns STL string. It can be
used for form the error message in Exception() constructor.

===========================================================================
*cv-getNumThreads*

int getNumThreads()¶
    Returns the number of threads used by OpenCV

The function returns the number of threads that is used by OpenCV.

See also: setNumThreads() , getThreadNum() .

===========================================================================
*cv-getThreadNum*

int getThreadNum()¶
    Returns index of the currently executed thread

The function returns 0-based index of the currently executed thread. The
function is only valid inside a parallel OpenMP region. When OpenCV is built
without OpenMP support, the function always returns 0.

See also: setNumThreads() , getNumThreads() .

===========================================================================
*cv-getTickCount*

int64 getTickCount()¶
    Returns the number of ticks

The function returns the number of ticks since the certain event (e.g. when the
machine was turned on). It can be used to initialize RNG() or to measure a
function execution time by reading the tick count before and after the function
call. See also the tick frequency.

===========================================================================
*cv-getTickFrequency*

double getTickFrequency()¶
    Returns the number of ticks per second

The function returns the number of ticks per second. That is, the following
code computes the execution time in seconds.

double t = (double)getTickCount();
// do something ...
t = ((double)getTickCount() - t)/getTickFrequency();

===========================================================================
*cv-setNumThreads*

void setNumThreads(int nthreads)~

    Sets the number of threads used by OpenCV

    Parameter: nthreads – The number of threads used by OpenCV

The function sets the number of threads used by OpenCV in parallel OpenMP
regions. If nthreads=0 , the function will use the default number of threads,
which is usually equal to the number of the processing cores.

See also: getNumThreads() , getThreadNum()

Help and Feedback

You did not find what you were looking for?

  • Try the Cheatsheet.
  • Ask a question in the user group/mailing list.
  • If you think something is missing or wrong in the documentation, please
    file a bug report.

Logo

Table Of Contents

  • Utility and System Functions and Macros
      □ cv::alignPtr
      □ cv::alignSize
      □ cv::allocate
      □ cv::deallocate
      □ CV_Assert
      □ cv::error
      □ Exception
      □ cv::fastMalloc
      □ cv::fastFree
      □ cv::format
      □ cv::getNumThreads
      □ cv::getThreadNum
      □ cv::getTickCount
      □ cv::getTickFrequency
      □ cv::setNumThreads

Previous topic

Clustering

Next topic

imgproc. Image Processing

This Page

  • Show Source

Quick search

[                  ] [Go] 
Enter search terms or a module, class or function name.

Navigation

  • index
  • next |
  • previous |
  • opencv v2.1 documentation »
  • core. The Core Functionality »

© Copyright 2010, authors. Created using Sphinx 0.6.2.


vim:tw=78:ts=4:ft=help:norl:
